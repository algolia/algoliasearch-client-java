// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost
// - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

package com.algolia.model.composition;

import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.databind.annotation.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/** Params */
public class Params {

  @JsonProperty("query")
  private String query;

  @JsonProperty("filters")
  private String filters;

  @JsonProperty("page")
  private Integer page;

  @JsonProperty("getRankingInfo")
  private Boolean getRankingInfo;

  @JsonProperty("relevancyStrictness")
  private Integer relevancyStrictness;

  @JsonProperty("facetFilters")
  private FacetFilters facetFilters;

  @JsonProperty("optionalFilters")
  private OptionalFilters optionalFilters;

  @JsonProperty("numericFilters")
  private NumericFilters numericFilters;

  @JsonProperty("hitsPerPage")
  private Integer hitsPerPage;

  @JsonProperty("aroundLatLng")
  private String aroundLatLng;

  @JsonProperty("aroundLatLngViaIP")
  private Boolean aroundLatLngViaIP;

  @JsonProperty("aroundRadius")
  private AroundRadius aroundRadius;

  @JsonProperty("aroundPrecision")
  private AroundPrecision aroundPrecision;

  @JsonProperty("minimumAroundRadius")
  private Integer minimumAroundRadius;

  @JsonProperty("insideBoundingBox")
  private InsideBoundingBox insideBoundingBox;

  @JsonProperty("insidePolygon")
  private List<List<Double>> insidePolygon;

  @JsonProperty("queryLanguages")
  private List<SupportedLanguage> queryLanguages;

  @JsonProperty("naturalLanguages")
  private List<SupportedLanguage> naturalLanguages;

  @JsonProperty("enableRules")
  private Boolean enableRules;

  @JsonProperty("ruleContexts")
  private List<String> ruleContexts;

  @JsonProperty("userToken")
  private String userToken;

  @JsonProperty("clickAnalytics")
  private Boolean clickAnalytics;

  @JsonProperty("analytics")
  private Boolean analytics;

  @JsonProperty("analyticsTags")
  private List<String> analyticsTags;

  @JsonProperty("enableABTest")
  private Boolean enableABTest;

  @JsonProperty("enableReRanking")
  private Boolean enableReRanking;

  public Params setQuery(String query) {
    this.query = query;
    return this;
  }

  /** Search query. */
  @javax.annotation.Nullable
  public String getQuery() {
    return query;
  }

  public Params setFilters(String filters) {
    this.filters = filters;
    return this;
  }

  /**
   * Filter expression to only include items that match the filter criteria in the response. You can
   * use these filter expressions: - **Numeric filters.** `<facet> <op> <number>`, where `<op>` is
   * one of `<`, `<=`, `=`, `!=`, `>`, `>=`. - **Ranges.** `<facet>:<lower> TO <upper>` where
   * `<lower>` and `<upper>` are the lower and upper limits of the range (inclusive). - **Facet
   * filters.** `<facet>:<value>` where `<facet>` is a facet attribute (case-sensitive) and
   * `<value>` a facet value. - **Tag filters.** `_tags:<value>` or just `<value>` (case-sensitive).
   * - **Boolean filters.** `<facet>: true | false`. You can combine filters with `AND`, `OR`, and
   * `NOT` operators with the following restrictions: - You can only combine filters of the same
   * type with `OR`. **Not supported:** `facet:value OR num > 3`. - You can't use `NOT` with
   * combinations of filters. **Not supported:** `NOT(facet:value OR facet:value)` - You can't
   * combine conjunctions (`AND`) with `OR`. **Not supported:** `facet:value OR (facet:value AND
   * facet:value)` Use quotes around your filters, if the facet attribute name or facet value has
   * spaces, keywords (`OR`, `AND`, `NOT`), or quotes. If a facet attribute is an array, the filter
   * matches if it matches at least one element of the array. For more information, see
   * [Filters](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering/).
   */
  @javax.annotation.Nullable
  public String getFilters() {
    return filters;
  }

  public Params setPage(Integer page) {
    this.page = page;
    return this;
  }

  /** Page of search results to retrieve. minimum: 0 */
  @javax.annotation.Nullable
  public Integer getPage() {
    return page;
  }

  public Params setGetRankingInfo(Boolean getRankingInfo) {
    this.getRankingInfo = getRankingInfo;
    return this;
  }

  /** Whether the search response should include detailed ranking information. */
  @javax.annotation.Nullable
  public Boolean getGetRankingInfo() {
    return getRankingInfo;
  }

  public Params setRelevancyStrictness(Integer relevancyStrictness) {
    this.relevancyStrictness = relevancyStrictness;
    return this;
  }

  /** Get relevancyStrictness */
  @javax.annotation.Nullable
  public Integer getRelevancyStrictness() {
    return relevancyStrictness;
  }

  public Params setFacetFilters(FacetFilters facetFilters) {
    this.facetFilters = facetFilters;
    return this;
  }

  /** Get facetFilters */
  @javax.annotation.Nullable
  public FacetFilters getFacetFilters() {
    return facetFilters;
  }

  public Params setOptionalFilters(OptionalFilters optionalFilters) {
    this.optionalFilters = optionalFilters;
    return this;
  }

  /** Get optionalFilters */
  @javax.annotation.Nullable
  public OptionalFilters getOptionalFilters() {
    return optionalFilters;
  }

  public Params setNumericFilters(NumericFilters numericFilters) {
    this.numericFilters = numericFilters;
    return this;
  }

  /** Get numericFilters */
  @javax.annotation.Nullable
  public NumericFilters getNumericFilters() {
    return numericFilters;
  }

  public Params setHitsPerPage(Integer hitsPerPage) {
    this.hitsPerPage = hitsPerPage;
    return this;
  }

  /** Number of hits per page. minimum: 1 maximum: 1000 */
  @javax.annotation.Nullable
  public Integer getHitsPerPage() {
    return hitsPerPage;
  }

  public Params setAroundLatLng(String aroundLatLng) {
    this.aroundLatLng = aroundLatLng;
    return this;
  }

  /**
   * Coordinates for the center of a circle, expressed as a comma-separated string of latitude and
   * longitude. Only records included within a circle around this central location are included in
   * the results. The radius of the circle is determined by the `aroundRadius` and
   * `minimumAroundRadius` settings. This parameter is ignored if you also specify `insidePolygon`
   * or `insideBoundingBox`.
   */
  @javax.annotation.Nullable
  public String getAroundLatLng() {
    return aroundLatLng;
  }

  public Params setAroundLatLngViaIP(Boolean aroundLatLngViaIP) {
    this.aroundLatLngViaIP = aroundLatLngViaIP;
    return this;
  }

  /** Whether to obtain the coordinates from the request's IP address. */
  @javax.annotation.Nullable
  public Boolean getAroundLatLngViaIP() {
    return aroundLatLngViaIP;
  }

  public Params setAroundRadius(AroundRadius aroundRadius) {
    this.aroundRadius = aroundRadius;
    return this;
  }

  /** Get aroundRadius */
  @javax.annotation.Nullable
  public AroundRadius getAroundRadius() {
    return aroundRadius;
  }

  public Params setAroundPrecision(AroundPrecision aroundPrecision) {
    this.aroundPrecision = aroundPrecision;
    return this;
  }

  /** Get aroundPrecision */
  @javax.annotation.Nullable
  public AroundPrecision getAroundPrecision() {
    return aroundPrecision;
  }

  public Params setMinimumAroundRadius(Integer minimumAroundRadius) {
    this.minimumAroundRadius = minimumAroundRadius;
    return this;
  }

  /**
   * Minimum radius (in meters) for a search around a location when `aroundRadius` isn't set.
   * minimum: 1
   */
  @javax.annotation.Nullable
  public Integer getMinimumAroundRadius() {
    return minimumAroundRadius;
  }

  public Params setInsideBoundingBox(InsideBoundingBox insideBoundingBox) {
    this.insideBoundingBox = insideBoundingBox;
    return this;
  }

  /** Get insideBoundingBox */
  @javax.annotation.Nullable
  public InsideBoundingBox getInsideBoundingBox() {
    return insideBoundingBox;
  }

  public Params setInsidePolygon(List<List<Double>> insidePolygon) {
    this.insidePolygon = insidePolygon;
    return this;
  }

  public Params addInsidePolygon(List<Double> insidePolygonItem) {
    if (this.insidePolygon == null) {
      this.insidePolygon = new ArrayList<>();
    }
    this.insidePolygon.add(insidePolygonItem);
    return this;
  }

  /**
   * Coordinates of a polygon in which to search. Polygons are defined by 3 to 10,000 points. Each
   * point is represented by its latitude and longitude. Provide multiple polygons as nested arrays.
   * For more information, see [filtering inside
   * polygons](https://www.algolia.com/doc/guides/managing-results/refine-results/geolocation/#filtering-inside-rectangular-or-polygonal-areas).
   * This parameter is ignored if you also specify `insideBoundingBox`.
   */
  @javax.annotation.Nullable
  public List<List<Double>> getInsidePolygon() {
    return insidePolygon;
  }

  public Params setQueryLanguages(List<SupportedLanguage> queryLanguages) {
    this.queryLanguages = queryLanguages;
    return this;
  }

  public Params addQueryLanguages(SupportedLanguage queryLanguagesItem) {
    if (this.queryLanguages == null) {
      this.queryLanguages = new ArrayList<>();
    }
    this.queryLanguages.add(queryLanguagesItem);
    return this;
  }

  /**
   * Languages for language-specific query processing steps such as plurals, stop-word removal, and
   * word-detection dictionaries. This setting sets a default list of languages used by the
   * `removeStopWords` and `ignorePlurals` settings. This setting also sets a dictionary for word
   * detection in the logogram-based
   * [CJK](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/normalization/#normalization-for-logogram-based-languages-cjk)
   * languages. To support this, you must place the CJK language **first**. **You should always
   * specify a query language.** If you don't specify an indexing language, the search engine uses
   * all [supported
   * languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/),
   * or the languages you specified with the `ignorePlurals` or `removeStopWords` parameters. This
   * can lead to unexpected search results. For more information, see [Language-specific
   * configuration](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/language-specific-configurations/).
   */
  @javax.annotation.Nullable
  public List<SupportedLanguage> getQueryLanguages() {
    return queryLanguages;
  }

  public Params setNaturalLanguages(List<SupportedLanguage> naturalLanguages) {
    this.naturalLanguages = naturalLanguages;
    return this;
  }

  public Params addNaturalLanguages(SupportedLanguage naturalLanguagesItem) {
    if (this.naturalLanguages == null) {
      this.naturalLanguages = new ArrayList<>();
    }
    this.naturalLanguages.add(naturalLanguagesItem);
    return this;
  }

  /**
   * ISO language codes that adjust settings that are useful for processing natural language queries
   * (as opposed to keyword searches): - Sets `removeStopWords` and `ignorePlurals` to the list of
   * provided languages. - Sets `removeWordsIfNoResults` to `allOptional`. - Adds a
   * `natural_language` attribute to `ruleContexts` and `analyticsTags`.
   */
  @javax.annotation.Nullable
  public List<SupportedLanguage> getNaturalLanguages() {
    return naturalLanguages;
  }

  public Params setEnableRules(Boolean enableRules) {
    this.enableRules = enableRules;
    return this;
  }

  /** Whether to enable rules. */
  @javax.annotation.Nullable
  public Boolean getEnableRules() {
    return enableRules;
  }

  public Params setRuleContexts(List<String> ruleContexts) {
    this.ruleContexts = ruleContexts;
    return this;
  }

  public Params addRuleContexts(String ruleContextsItem) {
    if (this.ruleContexts == null) {
      this.ruleContexts = new ArrayList<>();
    }
    this.ruleContexts.add(ruleContextsItem);
    return this;
  }

  /**
   * Assigns a rule context to the search query. [Rule
   * contexts](https://www.algolia.com/doc/guides/managing-results/rules/rules-overview/how-to/customize-search-results-by-platform/#whats-a-context)
   * are strings that you can use to trigger matching rules.
   */
  @javax.annotation.Nullable
  public List<String> getRuleContexts() {
    return ruleContexts;
  }

  public Params setUserToken(String userToken) {
    this.userToken = userToken;
    return this;
  }

  /**
   * Unique pseudonymous or anonymous user identifier. This helps with analytics and click and
   * conversion events. For more information, see [user
   * token](https://www.algolia.com/doc/guides/sending-events/concepts/usertoken/).
   */
  @javax.annotation.Nullable
  public String getUserToken() {
    return userToken;
  }

  public Params setClickAnalytics(Boolean clickAnalytics) {
    this.clickAnalytics = clickAnalytics;
    return this;
  }

  /**
   * Whether to include a `queryID` attribute in the response. The query ID is a unique identifier
   * for a search query and is required for tracking [click and conversion
   * events](https://www.algolia.com/guides/sending-events/getting-started/).
   */
  @javax.annotation.Nullable
  public Boolean getClickAnalytics() {
    return clickAnalytics;
  }

  public Params setAnalytics(Boolean analytics) {
    this.analytics = analytics;
    return this;
  }

  /** Whether this search will be included in Analytics. */
  @javax.annotation.Nullable
  public Boolean getAnalytics() {
    return analytics;
  }

  public Params setAnalyticsTags(List<String> analyticsTags) {
    this.analyticsTags = analyticsTags;
    return this;
  }

  public Params addAnalyticsTags(String analyticsTagsItem) {
    if (this.analyticsTags == null) {
      this.analyticsTags = new ArrayList<>();
    }
    this.analyticsTags.add(analyticsTagsItem);
    return this;
  }

  /**
   * Tags to apply to the query for [segmenting analytics
   * data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).
   */
  @javax.annotation.Nullable
  public List<String> getAnalyticsTags() {
    return analyticsTags;
  }

  public Params setEnableABTest(Boolean enableABTest) {
    this.enableABTest = enableABTest;
    return this;
  }

  /** Whether to enable A/B testing for this search. */
  @javax.annotation.Nullable
  public Boolean getEnableABTest() {
    return enableABTest;
  }

  public Params setEnableReRanking(Boolean enableReRanking) {
    this.enableReRanking = enableReRanking;
    return this;
  }

  /**
   * Whether this search will use [Dynamic
   * Re-Ranking](https://www.algolia.com/doc/guides/algolia-ai/re-ranking/). This setting only has
   * an effect if you activated Dynamic Re-Ranking for this index in the Algolia dashboard.
   */
  @javax.annotation.Nullable
  public Boolean getEnableReRanking() {
    return enableReRanking;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Params params = (Params) o;
    return (
      Objects.equals(this.query, params.query) &&
      Objects.equals(this.filters, params.filters) &&
      Objects.equals(this.page, params.page) &&
      Objects.equals(this.getRankingInfo, params.getRankingInfo) &&
      Objects.equals(this.relevancyStrictness, params.relevancyStrictness) &&
      Objects.equals(this.facetFilters, params.facetFilters) &&
      Objects.equals(this.optionalFilters, params.optionalFilters) &&
      Objects.equals(this.numericFilters, params.numericFilters) &&
      Objects.equals(this.hitsPerPage, params.hitsPerPage) &&
      Objects.equals(this.aroundLatLng, params.aroundLatLng) &&
      Objects.equals(this.aroundLatLngViaIP, params.aroundLatLngViaIP) &&
      Objects.equals(this.aroundRadius, params.aroundRadius) &&
      Objects.equals(this.aroundPrecision, params.aroundPrecision) &&
      Objects.equals(this.minimumAroundRadius, params.minimumAroundRadius) &&
      Objects.equals(this.insideBoundingBox, params.insideBoundingBox) &&
      Objects.equals(this.insidePolygon, params.insidePolygon) &&
      Objects.equals(this.queryLanguages, params.queryLanguages) &&
      Objects.equals(this.naturalLanguages, params.naturalLanguages) &&
      Objects.equals(this.enableRules, params.enableRules) &&
      Objects.equals(this.ruleContexts, params.ruleContexts) &&
      Objects.equals(this.userToken, params.userToken) &&
      Objects.equals(this.clickAnalytics, params.clickAnalytics) &&
      Objects.equals(this.analytics, params.analytics) &&
      Objects.equals(this.analyticsTags, params.analyticsTags) &&
      Objects.equals(this.enableABTest, params.enableABTest) &&
      Objects.equals(this.enableReRanking, params.enableReRanking)
    );
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      query,
      filters,
      page,
      getRankingInfo,
      relevancyStrictness,
      facetFilters,
      optionalFilters,
      numericFilters,
      hitsPerPage,
      aroundLatLng,
      aroundLatLngViaIP,
      aroundRadius,
      aroundPrecision,
      minimumAroundRadius,
      insideBoundingBox,
      insidePolygon,
      queryLanguages,
      naturalLanguages,
      enableRules,
      ruleContexts,
      userToken,
      clickAnalytics,
      analytics,
      analyticsTags,
      enableABTest,
      enableReRanking
    );
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Params {\n");
    sb.append("    query: ").append(toIndentedString(query)).append("\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("    page: ").append(toIndentedString(page)).append("\n");
    sb.append("    getRankingInfo: ").append(toIndentedString(getRankingInfo)).append("\n");
    sb.append("    relevancyStrictness: ").append(toIndentedString(relevancyStrictness)).append("\n");
    sb.append("    facetFilters: ").append(toIndentedString(facetFilters)).append("\n");
    sb.append("    optionalFilters: ").append(toIndentedString(optionalFilters)).append("\n");
    sb.append("    numericFilters: ").append(toIndentedString(numericFilters)).append("\n");
    sb.append("    hitsPerPage: ").append(toIndentedString(hitsPerPage)).append("\n");
    sb.append("    aroundLatLng: ").append(toIndentedString(aroundLatLng)).append("\n");
    sb.append("    aroundLatLngViaIP: ").append(toIndentedString(aroundLatLngViaIP)).append("\n");
    sb.append("    aroundRadius: ").append(toIndentedString(aroundRadius)).append("\n");
    sb.append("    aroundPrecision: ").append(toIndentedString(aroundPrecision)).append("\n");
    sb.append("    minimumAroundRadius: ").append(toIndentedString(minimumAroundRadius)).append("\n");
    sb.append("    insideBoundingBox: ").append(toIndentedString(insideBoundingBox)).append("\n");
    sb.append("    insidePolygon: ").append(toIndentedString(insidePolygon)).append("\n");
    sb.append("    queryLanguages: ").append(toIndentedString(queryLanguages)).append("\n");
    sb.append("    naturalLanguages: ").append(toIndentedString(naturalLanguages)).append("\n");
    sb.append("    enableRules: ").append(toIndentedString(enableRules)).append("\n");
    sb.append("    ruleContexts: ").append(toIndentedString(ruleContexts)).append("\n");
    sb.append("    userToken: ").append(toIndentedString(userToken)).append("\n");
    sb.append("    clickAnalytics: ").append(toIndentedString(clickAnalytics)).append("\n");
    sb.append("    analytics: ").append(toIndentedString(analytics)).append("\n");
    sb.append("    analyticsTags: ").append(toIndentedString(analyticsTags)).append("\n");
    sb.append("    enableABTest: ").append(toIndentedString(enableABTest)).append("\n");
    sb.append("    enableReRanking: ").append(toIndentedString(enableReRanking)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}
