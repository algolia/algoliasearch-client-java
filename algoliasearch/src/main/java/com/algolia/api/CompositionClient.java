// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost
// - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

package com.algolia.api;

import com.algolia.ApiClient;
import com.algolia.config.*;
import com.algolia.config.ClientOptions;
import com.algolia.exceptions.*;
import com.algolia.model.composition.*;
import com.algolia.utils.*;
import com.fasterxml.jackson.core.type.TypeReference;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;
import java.util.Random;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public class CompositionClient extends ApiClient {

  public CompositionClient(String appId, String apiKey) {
    this(appId, apiKey, null);
  }

  public CompositionClient(String appId, String apiKey, ClientOptions options) {
    super(
      appId,
      apiKey,
      "Composition",
      options,
      getDefaultHosts(appId),
      Duration.ofMillis(2000L),
      Duration.ofMillis(5000L),
      Duration.ofMillis(30000L)
    );
  }

  private static List<Host> getDefaultHosts(String appId) {
    List<Host> hosts = new ArrayList<>();
    hosts.add(new Host(appId + "-dsn.algolia.net", EnumSet.of(CallType.READ)));
    hosts.add(new Host(appId + ".algolia.net", EnumSet.of(CallType.WRITE)));

    List<Host> commonHosts = new ArrayList<>();
    commonHosts.add(new Host(appId + "-1.algolianet.com", EnumSet.of(CallType.READ, CallType.WRITE)));
    commonHosts.add(new Host(appId + "-2.algolianet.com", EnumSet.of(CallType.READ, CallType.WRITE)));
    commonHosts.add(new Host(appId + "-3.algolianet.com", EnumSet.of(CallType.READ, CallType.WRITE)));

    Collections.shuffle(commonHosts, new Random());

    return Stream.concat(hosts.stream(), commonHosts.stream()).collect(Collectors.toList());
  }

  /**
   * Runs a query on a single composition and returns matching results.
   *
   * @param compositionID Unique Composition ObjectID. (required)
   * @param requestBody (required)
   * @param innerType The class held by the index, could be your custom class or {@link Object}.
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public <T> SearchResponse<T> search(
    @Nonnull String compositionID,
    @Nonnull RequestBody requestBody,
    Class<T> innerType,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(searchAsync(compositionID, requestBody, innerType, requestOptions));
  }

  /**
   * Runs a query on a single composition and returns matching results.
   *
   * @param compositionID Unique Composition ObjectID. (required)
   * @param requestBody (required)
   * @param innerType The class held by the index, could be your custom class or {@link Object}.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public <T> SearchResponse<T> search(@Nonnull String compositionID, @Nonnull RequestBody requestBody, Class<T> innerType)
    throws AlgoliaRuntimeException {
    return this.search(compositionID, requestBody, innerType, null);
  }

  /**
   * (asynchronously) Runs a query on a single composition and returns matching results.
   *
   * @param compositionID Unique Composition ObjectID. (required)
   * @param requestBody (required)
   * @param innerType The class held by the index, could be your custom class or {@link Object}.
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public <T> CompletableFuture<SearchResponse<T>> searchAsync(
    @Nonnull String compositionID,
    @Nonnull RequestBody requestBody,
    Class<T> innerType,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(compositionID, "Parameter `compositionID` is required when calling `search`.");

    Parameters.requireNonNull(requestBody, "Parameter `requestBody` is required when calling `search`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/compositions/{compositionID}/run", compositionID)
      .setMethod("POST")
      .setBody(requestBody)
      .setRead(true)
      .build();
    return executeAsync(request, requestOptions, SearchResponse.class, innerType);
  }

  /**
   * (asynchronously) Runs a query on a single composition and returns matching results.
   *
   * @param compositionID Unique Composition ObjectID. (required)
   * @param requestBody (required)
   * @param innerType The class held by the index, could be your custom class or {@link Object}.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public <T> CompletableFuture<SearchResponse<T>> searchAsync(
    @Nonnull String compositionID,
    @Nonnull RequestBody requestBody,
    Class<T> innerType
  ) throws AlgoliaRuntimeException {
    return this.searchAsync(compositionID, requestBody, innerType, null);
  }

  /**
   * Searches for values of a specified facet attribute on the composition's main source's index. -
   * By default, facet values are sorted by decreasing count. You can adjust this with the
   * `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have **more than
   * 65 searchable facets and searchable attributes combined**.
   *
   * @param compositionID Unique Composition ObjectID. (required)
   * @param facetName Facet attribute in which to search for values. This attribute must be included
   *     in the `attributesForFaceting` index setting with the `searchable()` modifier. (required)
   * @param searchForFacetValuesRequest (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public SearchForFacetValuesResponse searchForFacetValues(
    @Nonnull String compositionID,
    @Nonnull String facetName,
    SearchForFacetValuesRequest searchForFacetValuesRequest,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(searchForFacetValuesAsync(compositionID, facetName, searchForFacetValuesRequest, requestOptions));
  }

  /**
   * Searches for values of a specified facet attribute on the composition's main source's index. -
   * By default, facet values are sorted by decreasing count. You can adjust this with the
   * `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have **more than
   * 65 searchable facets and searchable attributes combined**.
   *
   * @param compositionID Unique Composition ObjectID. (required)
   * @param facetName Facet attribute in which to search for values. This attribute must be included
   *     in the `attributesForFaceting` index setting with the `searchable()` modifier. (required)
   * @param searchForFacetValuesRequest (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public SearchForFacetValuesResponse searchForFacetValues(
    @Nonnull String compositionID,
    @Nonnull String facetName,
    SearchForFacetValuesRequest searchForFacetValuesRequest
  ) throws AlgoliaRuntimeException {
    return this.searchForFacetValues(compositionID, facetName, searchForFacetValuesRequest, null);
  }

  /**
   * Searches for values of a specified facet attribute on the composition's main source's index. -
   * By default, facet values are sorted by decreasing count. You can adjust this with the
   * `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have **more than
   * 65 searchable facets and searchable attributes combined**.
   *
   * @param compositionID Unique Composition ObjectID. (required)
   * @param facetName Facet attribute in which to search for values. This attribute must be included
   *     in the `attributesForFaceting` index setting with the `searchable()` modifier. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public SearchForFacetValuesResponse searchForFacetValues(
    @Nonnull String compositionID,
    @Nonnull String facetName,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return this.searchForFacetValues(compositionID, facetName, null, requestOptions);
  }

  /**
   * Searches for values of a specified facet attribute on the composition's main source's index. -
   * By default, facet values are sorted by decreasing count. You can adjust this with the
   * `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have **more than
   * 65 searchable facets and searchable attributes combined**.
   *
   * @param compositionID Unique Composition ObjectID. (required)
   * @param facetName Facet attribute in which to search for values. This attribute must be included
   *     in the `attributesForFaceting` index setting with the `searchable()` modifier. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public SearchForFacetValuesResponse searchForFacetValues(@Nonnull String compositionID, @Nonnull String facetName)
    throws AlgoliaRuntimeException {
    return this.searchForFacetValues(compositionID, facetName, null, null);
  }

  /**
   * (asynchronously) Searches for values of a specified facet attribute on the composition's main
   * source's index. - By default, facet values are sorted by decreasing count. You can adjust this
   * with the `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have
   * **more than 65 searchable facets and searchable attributes combined**.
   *
   * @param compositionID Unique Composition ObjectID. (required)
   * @param facetName Facet attribute in which to search for values. This attribute must be included
   *     in the `attributesForFaceting` index setting with the `searchable()` modifier. (required)
   * @param searchForFacetValuesRequest (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<SearchForFacetValuesResponse> searchForFacetValuesAsync(
    @Nonnull String compositionID,
    @Nonnull String facetName,
    SearchForFacetValuesRequest searchForFacetValuesRequest,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(compositionID, "Parameter `compositionID` is required when calling `searchForFacetValues`.");

    Parameters.requireNonNull(facetName, "Parameter `facetName` is required when calling `searchForFacetValues`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/compositions/{compositionID}/facets/{facetName}/query", compositionID, facetName)
      .setMethod("POST")
      .setBody(searchForFacetValuesRequest)
      .setRead(true)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<SearchForFacetValuesResponse>() {});
  }

  /**
   * (asynchronously) Searches for values of a specified facet attribute on the composition's main
   * source's index. - By default, facet values are sorted by decreasing count. You can adjust this
   * with the `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have
   * **more than 65 searchable facets and searchable attributes combined**.
   *
   * @param compositionID Unique Composition ObjectID. (required)
   * @param facetName Facet attribute in which to search for values. This attribute must be included
   *     in the `attributesForFaceting` index setting with the `searchable()` modifier. (required)
   * @param searchForFacetValuesRequest (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<SearchForFacetValuesResponse> searchForFacetValuesAsync(
    @Nonnull String compositionID,
    @Nonnull String facetName,
    SearchForFacetValuesRequest searchForFacetValuesRequest
  ) throws AlgoliaRuntimeException {
    return this.searchForFacetValuesAsync(compositionID, facetName, searchForFacetValuesRequest, null);
  }

  /**
   * (asynchronously) Searches for values of a specified facet attribute on the composition's main
   * source's index. - By default, facet values are sorted by decreasing count. You can adjust this
   * with the `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have
   * **more than 65 searchable facets and searchable attributes combined**.
   *
   * @param compositionID Unique Composition ObjectID. (required)
   * @param facetName Facet attribute in which to search for values. This attribute must be included
   *     in the `attributesForFaceting` index setting with the `searchable()` modifier. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<SearchForFacetValuesResponse> searchForFacetValuesAsync(
    @Nonnull String compositionID,
    @Nonnull String facetName,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return this.searchForFacetValuesAsync(compositionID, facetName, null, requestOptions);
  }

  /**
   * (asynchronously) Searches for values of a specified facet attribute on the composition's main
   * source's index. - By default, facet values are sorted by decreasing count. You can adjust this
   * with the `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have
   * **more than 65 searchable facets and searchable attributes combined**.
   *
   * @param compositionID Unique Composition ObjectID. (required)
   * @param facetName Facet attribute in which to search for values. This attribute must be included
   *     in the `attributesForFaceting` index setting with the `searchable()` modifier. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<SearchForFacetValuesResponse> searchForFacetValuesAsync(@Nonnull String compositionID, @Nonnull String facetName)
    throws AlgoliaRuntimeException {
    return this.searchForFacetValuesAsync(compositionID, facetName, null, null);
  }
}
