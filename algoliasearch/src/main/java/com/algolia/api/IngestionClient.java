// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost
// - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

package com.algolia.api;

import com.algolia.ApiClient;
import com.algolia.config.*;
import com.algolia.config.ClientOptions;
import com.algolia.exceptions.*;
import com.algolia.model.ingestion.*;
import com.algolia.utils.*;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.time.Duration;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public class IngestionClient extends ApiClient {

  private static final String[] allowedRegions = { "eu", "us" };

  public IngestionClient(String appId, String apiKey, String region) {
    this(appId, apiKey, region, null);
  }

  public IngestionClient(String appId, String apiKey, String region, ClientOptions options) {
    super(
      appId,
      apiKey,
      "Ingestion",
      options,
      getDefaultHosts(region),
      Duration.ofMillis(25000L),
      Duration.ofMillis(25000L),
      Duration.ofMillis(25000L)
    );
  }

  private static List<Host> getDefaultHosts(String region) throws AlgoliaRuntimeException {
    List<Host> hosts = new ArrayList<>();

    boolean found = false;
    if (region != null) {
      for (String allowed : allowedRegions) {
        if (allowed.equals(region)) {
          found = true;
          break;
        }
      }
    }

    if (region == null || !found) {
      throw new AlgoliaRuntimeException("`region` is required and must be one of the following: eu, us");
    }

    String url = "data.{region}.algolia.com".replace("{region}", region);

    hosts.add(new Host(url, EnumSet.of(CallType.READ, CallType.WRITE)));
    return hosts;
  }

  /**
   * Creates a new authentication resource.
   *
   * @param authenticationCreate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public AuthenticationCreateResponse createAuthentication(
    @Nonnull AuthenticationCreate authenticationCreate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(createAuthenticationAsync(authenticationCreate, requestOptions));
  }

  /**
   * Creates a new authentication resource.
   *
   * @param authenticationCreate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public AuthenticationCreateResponse createAuthentication(@Nonnull AuthenticationCreate authenticationCreate)
    throws AlgoliaRuntimeException {
    return this.createAuthentication(authenticationCreate, null);
  }

  /**
   * (asynchronously) Creates a new authentication resource.
   *
   * @param authenticationCreate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<AuthenticationCreateResponse> createAuthenticationAsync(
    @Nonnull AuthenticationCreate authenticationCreate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(authenticationCreate, "Parameter `authenticationCreate` is required when calling `createAuthentication`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/authentications").setMethod("POST").setBody(authenticationCreate).build();
    return executeAsync(request, requestOptions, new TypeReference<AuthenticationCreateResponse>() {});
  }

  /**
   * (asynchronously) Creates a new authentication resource.
   *
   * @param authenticationCreate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<AuthenticationCreateResponse> createAuthenticationAsync(@Nonnull AuthenticationCreate authenticationCreate)
    throws AlgoliaRuntimeException {
    return this.createAuthenticationAsync(authenticationCreate, null);
  }

  /**
   * Creates a new destination.
   *
   * @param destinationCreate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DestinationCreateResponse createDestination(@Nonnull DestinationCreate destinationCreate, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(createDestinationAsync(destinationCreate, requestOptions));
  }

  /**
   * Creates a new destination.
   *
   * @param destinationCreate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DestinationCreateResponse createDestination(@Nonnull DestinationCreate destinationCreate) throws AlgoliaRuntimeException {
    return this.createDestination(destinationCreate, null);
  }

  /**
   * (asynchronously) Creates a new destination.
   *
   * @param destinationCreate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DestinationCreateResponse> createDestinationAsync(
    @Nonnull DestinationCreate destinationCreate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(destinationCreate, "Parameter `destinationCreate` is required when calling `createDestination`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/destinations").setMethod("POST").setBody(destinationCreate).build();
    return executeAsync(request, requestOptions, new TypeReference<DestinationCreateResponse>() {});
  }

  /**
   * (asynchronously) Creates a new destination.
   *
   * @param destinationCreate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DestinationCreateResponse> createDestinationAsync(@Nonnull DestinationCreate destinationCreate)
    throws AlgoliaRuntimeException {
    return this.createDestinationAsync(destinationCreate, null);
  }

  /**
   * Creates a new source.
   *
   * @param sourceCreate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public SourceCreateResponse createSource(@Nonnull SourceCreate sourceCreate, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(createSourceAsync(sourceCreate, requestOptions));
  }

  /**
   * Creates a new source.
   *
   * @param sourceCreate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public SourceCreateResponse createSource(@Nonnull SourceCreate sourceCreate) throws AlgoliaRuntimeException {
    return this.createSource(sourceCreate, null);
  }

  /**
   * (asynchronously) Creates a new source.
   *
   * @param sourceCreate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<SourceCreateResponse> createSourceAsync(
    @Nonnull SourceCreate sourceCreate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(sourceCreate, "Parameter `sourceCreate` is required when calling `createSource`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/sources").setMethod("POST").setBody(sourceCreate).build();

    return executeAsync(request, requestOptions, new TypeReference<SourceCreateResponse>() {});
  }

  /**
   * (asynchronously) Creates a new source.
   *
   * @param sourceCreate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<SourceCreateResponse> createSourceAsync(@Nonnull SourceCreate sourceCreate) throws AlgoliaRuntimeException {
    return this.createSourceAsync(sourceCreate, null);
  }

  /**
   * Creates a new task.
   *
   * @param taskCreate Request body for creating a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TaskCreateResponse createTask(@Nonnull TaskCreate taskCreate, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(createTaskAsync(taskCreate, requestOptions));
  }

  /**
   * Creates a new task.
   *
   * @param taskCreate Request body for creating a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TaskCreateResponse createTask(@Nonnull TaskCreate taskCreate) throws AlgoliaRuntimeException {
    return this.createTask(taskCreate, null);
  }

  /**
   * (asynchronously) Creates a new task.
   *
   * @param taskCreate Request body for creating a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TaskCreateResponse> createTaskAsync(@Nonnull TaskCreate taskCreate, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskCreate, "Parameter `taskCreate` is required when calling `createTask`.");

    HttpRequest request = HttpRequest.builder().setPath("/2/tasks").setMethod("POST").setBody(taskCreate).build();

    return executeAsync(request, requestOptions, new TypeReference<TaskCreateResponse>() {});
  }

  /**
   * (asynchronously) Creates a new task.
   *
   * @param taskCreate Request body for creating a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TaskCreateResponse> createTaskAsync(@Nonnull TaskCreate taskCreate) throws AlgoliaRuntimeException {
    return this.createTaskAsync(taskCreate, null);
  }

  /**
   * Creates a new task using the v1 endpoint, please use `createTask` instead.
   *
   * @param taskCreate Request body for creating a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public TaskCreateResponse createTaskV1(@Nonnull TaskCreateV1 taskCreate, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(createTaskV1Async(taskCreate, requestOptions));
  }

  /**
   * Creates a new task using the v1 endpoint, please use `createTask` instead.
   *
   * @param taskCreate Request body for creating a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public TaskCreateResponse createTaskV1(@Nonnull TaskCreateV1 taskCreate) throws AlgoliaRuntimeException {
    return this.createTaskV1(taskCreate, null);
  }

  /**
   * (asynchronously) Creates a new task using the v1 endpoint, please use `createTask` instead.
   *
   * @param taskCreate Request body for creating a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<TaskCreateResponse> createTaskV1Async(@Nonnull TaskCreateV1 taskCreate, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskCreate, "Parameter `taskCreate` is required when calling `createTaskV1`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/tasks").setMethod("POST").setBody(taskCreate).build();

    return executeAsync(request, requestOptions, new TypeReference<TaskCreateResponse>() {});
  }

  /**
   * (asynchronously) Creates a new task using the v1 endpoint, please use `createTask` instead.
   *
   * @param taskCreate Request body for creating a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<TaskCreateResponse> createTaskV1Async(@Nonnull TaskCreateV1 taskCreate) throws AlgoliaRuntimeException {
    return this.createTaskV1Async(taskCreate, null);
  }

  /**
   * Creates a new transformation.
   *
   * @param transformationCreate Request body for creating a transformation. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TransformationCreateResponse createTransformation(
    @Nonnull TransformationCreate transformationCreate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(createTransformationAsync(transformationCreate, requestOptions));
  }

  /**
   * Creates a new transformation.
   *
   * @param transformationCreate Request body for creating a transformation. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TransformationCreateResponse createTransformation(@Nonnull TransformationCreate transformationCreate)
    throws AlgoliaRuntimeException {
    return this.createTransformation(transformationCreate, null);
  }

  /**
   * (asynchronously) Creates a new transformation.
   *
   * @param transformationCreate Request body for creating a transformation. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TransformationCreateResponse> createTransformationAsync(
    @Nonnull TransformationCreate transformationCreate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(transformationCreate, "Parameter `transformationCreate` is required when calling `createTransformation`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/transformations").setMethod("POST").setBody(transformationCreate).build();
    return executeAsync(request, requestOptions, new TypeReference<TransformationCreateResponse>() {});
  }

  /**
   * (asynchronously) Creates a new transformation.
   *
   * @param transformationCreate Request body for creating a transformation. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TransformationCreateResponse> createTransformationAsync(@Nonnull TransformationCreate transformationCreate)
    throws AlgoliaRuntimeException {
    return this.createTransformationAsync(transformationCreate, null);
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customDelete(@Nonnull String path, Map<String, Object> parameters, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(customDeleteAsync(path, parameters, requestOptions));
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customDelete(@Nonnull String path, Map<String, Object> parameters) throws AlgoliaRuntimeException {
    return this.customDelete(path, parameters, null);
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customDelete(@Nonnull String path, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.customDelete(path, null, requestOptions);
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customDelete(@Nonnull String path) throws AlgoliaRuntimeException {
    return this.customDelete(path, null, null);
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customDeleteAsync(
    @Nonnull String path,
    Map<String, Object> parameters,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(path, "Parameter `path` is required when calling `customDelete`.");

    HttpRequest request = HttpRequest.builder().setPathEncoded("/{path}", path).setMethod("DELETE").addQueryParameters(parameters).build();
    return executeAsync(request, requestOptions, new TypeReference<Object>() {});
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customDeleteAsync(@Nonnull String path, Map<String, Object> parameters) throws AlgoliaRuntimeException {
    return this.customDeleteAsync(path, parameters, null);
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customDeleteAsync(@Nonnull String path, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return this.customDeleteAsync(path, null, requestOptions);
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customDeleteAsync(@Nonnull String path) throws AlgoliaRuntimeException {
    return this.customDeleteAsync(path, null, null);
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customGet(@Nonnull String path, Map<String, Object> parameters, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(customGetAsync(path, parameters, requestOptions));
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customGet(@Nonnull String path, Map<String, Object> parameters) throws AlgoliaRuntimeException {
    return this.customGet(path, parameters, null);
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customGet(@Nonnull String path, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.customGet(path, null, requestOptions);
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customGet(@Nonnull String path) throws AlgoliaRuntimeException {
    return this.customGet(path, null, null);
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customGetAsync(
    @Nonnull String path,
    Map<String, Object> parameters,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(path, "Parameter `path` is required when calling `customGet`.");

    HttpRequest request = HttpRequest.builder().setPathEncoded("/{path}", path).setMethod("GET").addQueryParameters(parameters).build();
    return executeAsync(request, requestOptions, new TypeReference<Object>() {});
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customGetAsync(@Nonnull String path, Map<String, Object> parameters) throws AlgoliaRuntimeException {
    return this.customGetAsync(path, parameters, null);
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customGetAsync(@Nonnull String path, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return this.customGetAsync(path, null, requestOptions);
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customGetAsync(@Nonnull String path) throws AlgoliaRuntimeException {
    return this.customGetAsync(path, null, null);
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @param body Parameters to send with the custom request. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customPost(@Nonnull String path, Map<String, Object> parameters, Object body, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(customPostAsync(path, parameters, body, requestOptions));
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @param body Parameters to send with the custom request. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customPost(@Nonnull String path, Map<String, Object> parameters, Object body) throws AlgoliaRuntimeException {
    return this.customPost(path, parameters, body, null);
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customPost(@Nonnull String path, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.customPost(path, null, null, requestOptions);
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customPost(@Nonnull String path) throws AlgoliaRuntimeException {
    return this.customPost(path, null, null, null);
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @param body Parameters to send with the custom request. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customPostAsync(
    @Nonnull String path,
    Map<String, Object> parameters,
    Object body,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(path, "Parameter `path` is required when calling `customPost`.");

    HttpRequest request = HttpRequest.builder()
      .setPathEncoded("/{path}", path)
      .setMethod("POST")
      .setBody(body)
      .addQueryParameters(parameters)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<Object>() {});
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @param body Parameters to send with the custom request. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customPostAsync(@Nonnull String path, Map<String, Object> parameters, Object body)
    throws AlgoliaRuntimeException {
    return this.customPostAsync(path, parameters, body, null);
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customPostAsync(@Nonnull String path, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return this.customPostAsync(path, null, null, requestOptions);
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customPostAsync(@Nonnull String path) throws AlgoliaRuntimeException {
    return this.customPostAsync(path, null, null, null);
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @param body Parameters to send with the custom request. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customPut(@Nonnull String path, Map<String, Object> parameters, Object body, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(customPutAsync(path, parameters, body, requestOptions));
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @param body Parameters to send with the custom request. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customPut(@Nonnull String path, Map<String, Object> parameters, Object body) throws AlgoliaRuntimeException {
    return this.customPut(path, parameters, body, null);
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customPut(@Nonnull String path, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.customPut(path, null, null, requestOptions);
  }

  /**
   * This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Object customPut(@Nonnull String path) throws AlgoliaRuntimeException {
    return this.customPut(path, null, null, null);
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @param body Parameters to send with the custom request. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customPutAsync(
    @Nonnull String path,
    Map<String, Object> parameters,
    Object body,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(path, "Parameter `path` is required when calling `customPut`.");

    HttpRequest request = HttpRequest.builder()
      .setPathEncoded("/{path}", path)
      .setMethod("PUT")
      .setBody(body)
      .addQueryParameters(parameters)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<Object>() {});
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param parameters Query parameters to apply to the current query. (optional)
   * @param body Parameters to send with the custom request. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customPutAsync(@Nonnull String path, Map<String, Object> parameters, Object body)
    throws AlgoliaRuntimeException {
    return this.customPutAsync(path, parameters, body, null);
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customPutAsync(@Nonnull String path, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return this.customPutAsync(path, null, null, requestOptions);
  }

  /**
   * (asynchronously) This method lets you send requests to the Algolia REST API.
   *
   * @param path Path of the endpoint, for example `1/newFeature`. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Object> customPutAsync(@Nonnull String path) throws AlgoliaRuntimeException {
    return this.customPutAsync(path, null, null, null);
  }

  /**
   * Deletes an authentication resource. You can't delete authentication resources that are used by
   * a source or a destination.
   *
   * @param authenticationID Unique identifier of an authentication resource. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DeleteResponse deleteAuthentication(@Nonnull String authenticationID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(deleteAuthenticationAsync(authenticationID, requestOptions));
  }

  /**
   * Deletes an authentication resource. You can't delete authentication resources that are used by
   * a source or a destination.
   *
   * @param authenticationID Unique identifier of an authentication resource. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DeleteResponse deleteAuthentication(@Nonnull String authenticationID) throws AlgoliaRuntimeException {
    return this.deleteAuthentication(authenticationID, null);
  }

  /**
   * (asynchronously) Deletes an authentication resource. You can't delete authentication resources
   * that are used by a source or a destination.
   *
   * @param authenticationID Unique identifier of an authentication resource. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DeleteResponse> deleteAuthenticationAsync(
    @Nonnull String authenticationID,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(authenticationID, "Parameter `authenticationID` is required when calling `deleteAuthentication`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/authentications/{authenticationID}", authenticationID)
      .setMethod("DELETE")
      .build();
    return executeAsync(request, requestOptions, new TypeReference<DeleteResponse>() {});
  }

  /**
   * (asynchronously) Deletes an authentication resource. You can't delete authentication resources
   * that are used by a source or a destination.
   *
   * @param authenticationID Unique identifier of an authentication resource. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DeleteResponse> deleteAuthenticationAsync(@Nonnull String authenticationID) throws AlgoliaRuntimeException {
    return this.deleteAuthenticationAsync(authenticationID, null);
  }

  /**
   * Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.
   *
   * @param destinationID Unique identifier of a destination. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DeleteResponse deleteDestination(@Nonnull String destinationID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(deleteDestinationAsync(destinationID, requestOptions));
  }

  /**
   * Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.
   *
   * @param destinationID Unique identifier of a destination. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DeleteResponse deleteDestination(@Nonnull String destinationID) throws AlgoliaRuntimeException {
    return this.deleteDestination(destinationID, null);
  }

  /**
   * (asynchronously) Deletes a destination by its ID. You can't delete destinations that are
   * referenced in tasks.
   *
   * @param destinationID Unique identifier of a destination. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DeleteResponse> deleteDestinationAsync(@Nonnull String destinationID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(destinationID, "Parameter `destinationID` is required when calling `deleteDestination`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/destinations/{destinationID}", destinationID).setMethod("DELETE").build();
    return executeAsync(request, requestOptions, new TypeReference<DeleteResponse>() {});
  }

  /**
   * (asynchronously) Deletes a destination by its ID. You can't delete destinations that are
   * referenced in tasks.
   *
   * @param destinationID Unique identifier of a destination. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DeleteResponse> deleteDestinationAsync(@Nonnull String destinationID) throws AlgoliaRuntimeException {
    return this.deleteDestinationAsync(destinationID, null);
  }

  /**
   * Deletes a source by its ID. You can't delete sources that are referenced in tasks.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DeleteResponse deleteSource(@Nonnull String sourceID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(deleteSourceAsync(sourceID, requestOptions));
  }

  /**
   * Deletes a source by its ID. You can't delete sources that are referenced in tasks.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DeleteResponse deleteSource(@Nonnull String sourceID) throws AlgoliaRuntimeException {
    return this.deleteSource(sourceID, null);
  }

  /**
   * (asynchronously) Deletes a source by its ID. You can't delete sources that are referenced in
   * tasks.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DeleteResponse> deleteSourceAsync(@Nonnull String sourceID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(sourceID, "Parameter `sourceID` is required when calling `deleteSource`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/sources/{sourceID}", sourceID).setMethod("DELETE").build();
    return executeAsync(request, requestOptions, new TypeReference<DeleteResponse>() {});
  }

  /**
   * (asynchronously) Deletes a source by its ID. You can't delete sources that are referenced in
   * tasks.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DeleteResponse> deleteSourceAsync(@Nonnull String sourceID) throws AlgoliaRuntimeException {
    return this.deleteSourceAsync(sourceID, null);
  }

  /**
   * Deletes a task by its ID.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DeleteResponse deleteTask(@Nonnull String taskID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(deleteTaskAsync(taskID, requestOptions));
  }

  /**
   * Deletes a task by its ID.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DeleteResponse deleteTask(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.deleteTask(taskID, null);
  }

  /**
   * (asynchronously) Deletes a task by its ID.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DeleteResponse> deleteTaskAsync(@Nonnull String taskID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `deleteTask`.");

    HttpRequest request = HttpRequest.builder().setPath("/2/tasks/{taskID}", taskID).setMethod("DELETE").build();

    return executeAsync(request, requestOptions, new TypeReference<DeleteResponse>() {});
  }

  /**
   * (asynchronously) Deletes a task by its ID.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DeleteResponse> deleteTaskAsync(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.deleteTaskAsync(taskID, null);
  }

  /**
   * Deletes a task by its ID using the v1 endpoint, please use `deleteTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public DeleteResponse deleteTaskV1(@Nonnull String taskID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(deleteTaskV1Async(taskID, requestOptions));
  }

  /**
   * Deletes a task by its ID using the v1 endpoint, please use `deleteTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public DeleteResponse deleteTaskV1(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.deleteTaskV1(taskID, null);
  }

  /**
   * (asynchronously) Deletes a task by its ID using the v1 endpoint, please use `deleteTask`
   * instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<DeleteResponse> deleteTaskV1Async(@Nonnull String taskID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `deleteTaskV1`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/tasks/{taskID}", taskID).setMethod("DELETE").build();

    return executeAsync(request, requestOptions, new TypeReference<DeleteResponse>() {});
  }

  /**
   * (asynchronously) Deletes a task by its ID using the v1 endpoint, please use `deleteTask`
   * instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<DeleteResponse> deleteTaskV1Async(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.deleteTaskV1Async(taskID, null);
  }

  /**
   * Deletes a transformation by its ID.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DeleteResponse deleteTransformation(@Nonnull String transformationID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(deleteTransformationAsync(transformationID, requestOptions));
  }

  /**
   * Deletes a transformation by its ID.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DeleteResponse deleteTransformation(@Nonnull String transformationID) throws AlgoliaRuntimeException {
    return this.deleteTransformation(transformationID, null);
  }

  /**
   * (asynchronously) Deletes a transformation by its ID.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DeleteResponse> deleteTransformationAsync(
    @Nonnull String transformationID,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(transformationID, "Parameter `transformationID` is required when calling `deleteTransformation`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/transformations/{transformationID}", transformationID)
      .setMethod("DELETE")
      .build();
    return executeAsync(request, requestOptions, new TypeReference<DeleteResponse>() {});
  }

  /**
   * (asynchronously) Deletes a transformation by its ID.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DeleteResponse> deleteTransformationAsync(@Nonnull String transformationID) throws AlgoliaRuntimeException {
    return this.deleteTransformationAsync(transformationID, null);
  }

  /**
   * Disables a task.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TaskUpdateResponse disableTask(@Nonnull String taskID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(disableTaskAsync(taskID, requestOptions));
  }

  /**
   * Disables a task.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TaskUpdateResponse disableTask(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.disableTask(taskID, null);
  }

  /**
   * (asynchronously) Disables a task.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TaskUpdateResponse> disableTaskAsync(@Nonnull String taskID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `disableTask`.");

    HttpRequest request = HttpRequest.builder().setPath("/2/tasks/{taskID}/disable", taskID).setMethod("PUT").build();

    return executeAsync(request, requestOptions, new TypeReference<TaskUpdateResponse>() {});
  }

  /**
   * (asynchronously) Disables a task.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TaskUpdateResponse> disableTaskAsync(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.disableTaskAsync(taskID, null);
  }

  /**
   * Disables a task using the v1 endpoint, please use `disableTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public TaskUpdateResponse disableTaskV1(@Nonnull String taskID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(disableTaskV1Async(taskID, requestOptions));
  }

  /**
   * Disables a task using the v1 endpoint, please use `disableTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public TaskUpdateResponse disableTaskV1(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.disableTaskV1(taskID, null);
  }

  /**
   * (asynchronously) Disables a task using the v1 endpoint, please use `disableTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<TaskUpdateResponse> disableTaskV1Async(@Nonnull String taskID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `disableTaskV1`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/tasks/{taskID}/disable", taskID).setMethod("PUT").build();

    return executeAsync(request, requestOptions, new TypeReference<TaskUpdateResponse>() {});
  }

  /**
   * (asynchronously) Disables a task using the v1 endpoint, please use `disableTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<TaskUpdateResponse> disableTaskV1Async(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.disableTaskV1Async(taskID, null);
  }

  /**
   * Enables a task.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TaskUpdateResponse enableTask(@Nonnull String taskID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(enableTaskAsync(taskID, requestOptions));
  }

  /**
   * Enables a task.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TaskUpdateResponse enableTask(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.enableTask(taskID, null);
  }

  /**
   * (asynchronously) Enables a task.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TaskUpdateResponse> enableTaskAsync(@Nonnull String taskID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `enableTask`.");

    HttpRequest request = HttpRequest.builder().setPath("/2/tasks/{taskID}/enable", taskID).setMethod("PUT").build();

    return executeAsync(request, requestOptions, new TypeReference<TaskUpdateResponse>() {});
  }

  /**
   * (asynchronously) Enables a task.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TaskUpdateResponse> enableTaskAsync(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.enableTaskAsync(taskID, null);
  }

  /**
   * Enables a task using the v1 endpoint, please use `enableTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public TaskUpdateResponse enableTaskV1(@Nonnull String taskID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(enableTaskV1Async(taskID, requestOptions));
  }

  /**
   * Enables a task using the v1 endpoint, please use `enableTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public TaskUpdateResponse enableTaskV1(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.enableTaskV1(taskID, null);
  }

  /**
   * (asynchronously) Enables a task using the v1 endpoint, please use `enableTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<TaskUpdateResponse> enableTaskV1Async(@Nonnull String taskID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `enableTaskV1`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/tasks/{taskID}/enable", taskID).setMethod("PUT").build();

    return executeAsync(request, requestOptions, new TypeReference<TaskUpdateResponse>() {});
  }

  /**
   * (asynchronously) Enables a task using the v1 endpoint, please use `enableTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<TaskUpdateResponse> enableTaskV1Async(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.enableTaskV1Async(taskID, null);
  }

  /**
   * Retrieves an authentication resource by its ID.
   *
   * @param authenticationID Unique identifier of an authentication resource. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Authentication getAuthentication(@Nonnull String authenticationID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(getAuthenticationAsync(authenticationID, requestOptions));
  }

  /**
   * Retrieves an authentication resource by its ID.
   *
   * @param authenticationID Unique identifier of an authentication resource. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Authentication getAuthentication(@Nonnull String authenticationID) throws AlgoliaRuntimeException {
    return this.getAuthentication(authenticationID, null);
  }

  /**
   * (asynchronously) Retrieves an authentication resource by its ID.
   *
   * @param authenticationID Unique identifier of an authentication resource. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Authentication> getAuthenticationAsync(
    @Nonnull String authenticationID,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(authenticationID, "Parameter `authenticationID` is required when calling `getAuthentication`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/authentications/{authenticationID}", authenticationID).setMethod("GET").build();
    return executeAsync(request, requestOptions, new TypeReference<Authentication>() {});
  }

  /**
   * (asynchronously) Retrieves an authentication resource by its ID.
   *
   * @param authenticationID Unique identifier of an authentication resource. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Authentication> getAuthenticationAsync(@Nonnull String authenticationID) throws AlgoliaRuntimeException {
    return this.getAuthenticationAsync(authenticationID, null);
  }

  /**
   * Retrieves a destination by its ID.
   *
   * @param destinationID Unique identifier of a destination. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Destination getDestination(@Nonnull String destinationID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(getDestinationAsync(destinationID, requestOptions));
  }

  /**
   * Retrieves a destination by its ID.
   *
   * @param destinationID Unique identifier of a destination. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Destination getDestination(@Nonnull String destinationID) throws AlgoliaRuntimeException {
    return this.getDestination(destinationID, null);
  }

  /**
   * (asynchronously) Retrieves a destination by its ID.
   *
   * @param destinationID Unique identifier of a destination. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Destination> getDestinationAsync(@Nonnull String destinationID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(destinationID, "Parameter `destinationID` is required when calling `getDestination`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/destinations/{destinationID}", destinationID).setMethod("GET").build();
    return executeAsync(request, requestOptions, new TypeReference<Destination>() {});
  }

  /**
   * (asynchronously) Retrieves a destination by its ID.
   *
   * @param destinationID Unique identifier of a destination. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Destination> getDestinationAsync(@Nonnull String destinationID) throws AlgoliaRuntimeException {
    return this.getDestinationAsync(destinationID, null);
  }

  /**
   * Retrieves a single task run event by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @param eventID Unique identifier of an event. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Event getEvent(@Nonnull String runID, @Nonnull String eventID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(getEventAsync(runID, eventID, requestOptions));
  }

  /**
   * Retrieves a single task run event by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @param eventID Unique identifier of an event. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Event getEvent(@Nonnull String runID, @Nonnull String eventID) throws AlgoliaRuntimeException {
    return this.getEvent(runID, eventID, null);
  }

  /**
   * (asynchronously) Retrieves a single task run event by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @param eventID Unique identifier of an event. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Event> getEventAsync(@Nonnull String runID, @Nonnull String eventID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(runID, "Parameter `runID` is required when calling `getEvent`.");

    Parameters.requireNonNull(eventID, "Parameter `eventID` is required when calling `getEvent`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/runs/{runID}/events/{eventID}", runID, eventID).setMethod("GET").build();
    return executeAsync(request, requestOptions, new TypeReference<Event>() {});
  }

  /**
   * (asynchronously) Retrieves a single task run event by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @param eventID Unique identifier of an event. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Event> getEventAsync(@Nonnull String runID, @Nonnull String eventID) throws AlgoliaRuntimeException {
    return this.getEventAsync(runID, eventID, null);
  }

  /**
   * Retrieve a single task run by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Run getRun(@Nonnull String runID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(getRunAsync(runID, requestOptions));
  }

  /**
   * Retrieve a single task run by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Run getRun(@Nonnull String runID) throws AlgoliaRuntimeException {
    return this.getRun(runID, null);
  }

  /**
   * (asynchronously) Retrieve a single task run by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Run> getRunAsync(@Nonnull String runID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(runID, "Parameter `runID` is required when calling `getRun`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/runs/{runID}", runID).setMethod("GET").build();

    return executeAsync(request, requestOptions, new TypeReference<Run>() {});
  }

  /**
   * (asynchronously) Retrieve a single task run by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Run> getRunAsync(@Nonnull String runID) throws AlgoliaRuntimeException {
    return this.getRunAsync(runID, null);
  }

  /**
   * Retrieve a source by its ID.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Source getSource(@Nonnull String sourceID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(getSourceAsync(sourceID, requestOptions));
  }

  /**
   * Retrieve a source by its ID.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Source getSource(@Nonnull String sourceID) throws AlgoliaRuntimeException {
    return this.getSource(sourceID, null);
  }

  /**
   * (asynchronously) Retrieve a source by its ID.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Source> getSourceAsync(@Nonnull String sourceID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(sourceID, "Parameter `sourceID` is required when calling `getSource`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/sources/{sourceID}", sourceID).setMethod("GET").build();

    return executeAsync(request, requestOptions, new TypeReference<Source>() {});
  }

  /**
   * (asynchronously) Retrieve a source by its ID.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Source> getSourceAsync(@Nonnull String sourceID) throws AlgoliaRuntimeException {
    return this.getSourceAsync(sourceID, null);
  }

  /**
   * Retrieves a task by its ID.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Task getTask(@Nonnull String taskID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(getTaskAsync(taskID, requestOptions));
  }

  /**
   * Retrieves a task by its ID.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Task getTask(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.getTask(taskID, null);
  }

  /**
   * (asynchronously) Retrieves a task by its ID.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Task> getTaskAsync(@Nonnull String taskID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `getTask`.");

    HttpRequest request = HttpRequest.builder().setPath("/2/tasks/{taskID}", taskID).setMethod("GET").build();

    return executeAsync(request, requestOptions, new TypeReference<Task>() {});
  }

  /**
   * (asynchronously) Retrieves a task by its ID.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Task> getTaskAsync(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.getTaskAsync(taskID, null);
  }

  /**
   * Retrieves a task by its ID using the v1 endpoint, please use `getTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public TaskV1 getTaskV1(@Nonnull String taskID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(getTaskV1Async(taskID, requestOptions));
  }

  /**
   * Retrieves a task by its ID using the v1 endpoint, please use `getTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public TaskV1 getTaskV1(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.getTaskV1(taskID, null);
  }

  /**
   * (asynchronously) Retrieves a task by its ID using the v1 endpoint, please use `getTask`
   * instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<TaskV1> getTaskV1Async(@Nonnull String taskID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `getTaskV1`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/tasks/{taskID}", taskID).setMethod("GET").build();

    return executeAsync(request, requestOptions, new TypeReference<TaskV1>() {});
  }

  /**
   * (asynchronously) Retrieves a task by its ID using the v1 endpoint, please use `getTask`
   * instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<TaskV1> getTaskV1Async(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.getTaskV1Async(taskID, null);
  }

  /**
   * Retrieves a transformation by its ID.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Transformation getTransformation(@Nonnull String transformationID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(getTransformationAsync(transformationID, requestOptions));
  }

  /**
   * Retrieves a transformation by its ID.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public Transformation getTransformation(@Nonnull String transformationID) throws AlgoliaRuntimeException {
    return this.getTransformation(transformationID, null);
  }

  /**
   * (asynchronously) Retrieves a transformation by its ID.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Transformation> getTransformationAsync(
    @Nonnull String transformationID,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(transformationID, "Parameter `transformationID` is required when calling `getTransformation`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/transformations/{transformationID}", transformationID).setMethod("GET").build();
    return executeAsync(request, requestOptions, new TypeReference<Transformation>() {});
  }

  /**
   * (asynchronously) Retrieves a transformation by its ID.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<Transformation> getTransformationAsync(@Nonnull String transformationID) throws AlgoliaRuntimeException {
    return this.getTransformationAsync(transformationID, null);
  }

  /**
   * Retrieves a list of all authentication resources.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param type Type of authentication resource to retrieve. (optional)
   * @param platform Ecommerce platform for which to retrieve authentications. (optional)
   * @param sort Property by which to sort the list of authentications. (optional, default to
   *     createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListAuthenticationsResponse listAuthentications(
    Integer itemsPerPage,
    Integer page,
    List<AuthenticationType> type,
    List<PlatformWithNone> platform,
    AuthenticationSortKeys sort,
    OrderKeys order,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(listAuthenticationsAsync(itemsPerPage, page, type, platform, sort, order, requestOptions));
  }

  /**
   * Retrieves a list of all authentication resources.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param type Type of authentication resource to retrieve. (optional)
   * @param platform Ecommerce platform for which to retrieve authentications. (optional)
   * @param sort Property by which to sort the list of authentications. (optional, default to
   *     createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListAuthenticationsResponse listAuthentications(
    Integer itemsPerPage,
    Integer page,
    List<AuthenticationType> type,
    List<PlatformWithNone> platform,
    AuthenticationSortKeys sort,
    OrderKeys order
  ) throws AlgoliaRuntimeException {
    return this.listAuthentications(itemsPerPage, page, type, platform, sort, order, null);
  }

  /**
   * Retrieves a list of all authentication resources.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListAuthenticationsResponse listAuthentications(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.listAuthentications(null, null, null, null, null, null, requestOptions);
  }

  /**
   * Retrieves a list of all authentication resources.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListAuthenticationsResponse listAuthentications() throws AlgoliaRuntimeException {
    return this.listAuthentications(null, null, null, null, null, null, null);
  }

  /**
   * (asynchronously) Retrieves a list of all authentication resources.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param type Type of authentication resource to retrieve. (optional)
   * @param platform Ecommerce platform for which to retrieve authentications. (optional)
   * @param sort Property by which to sort the list of authentications. (optional, default to
   *     createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListAuthenticationsResponse> listAuthenticationsAsync(
    Integer itemsPerPage,
    Integer page,
    List<AuthenticationType> type,
    List<PlatformWithNone> platform,
    AuthenticationSortKeys sort,
    OrderKeys order,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    HttpRequest request = HttpRequest.builder()
      .setPath("/1/authentications")
      .setMethod("GET")
      .addQueryParameter("itemsPerPage", itemsPerPage)
      .addQueryParameter("page", page)
      .addQueryParameter("type", type)
      .addQueryParameter("platform", platform)
      .addQueryParameter("sort", sort)
      .addQueryParameter("order", order)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<ListAuthenticationsResponse>() {});
  }

  /**
   * (asynchronously) Retrieves a list of all authentication resources.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param type Type of authentication resource to retrieve. (optional)
   * @param platform Ecommerce platform for which to retrieve authentications. (optional)
   * @param sort Property by which to sort the list of authentications. (optional, default to
   *     createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListAuthenticationsResponse> listAuthenticationsAsync(
    Integer itemsPerPage,
    Integer page,
    List<AuthenticationType> type,
    List<PlatformWithNone> platform,
    AuthenticationSortKeys sort,
    OrderKeys order
  ) throws AlgoliaRuntimeException {
    return this.listAuthenticationsAsync(itemsPerPage, page, type, platform, sort, order, null);
  }

  /**
   * (asynchronously) Retrieves a list of all authentication resources.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListAuthenticationsResponse> listAuthenticationsAsync(@Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return this.listAuthenticationsAsync(null, null, null, null, null, null, requestOptions);
  }

  /**
   * (asynchronously) Retrieves a list of all authentication resources.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListAuthenticationsResponse> listAuthenticationsAsync() throws AlgoliaRuntimeException {
    return this.listAuthenticationsAsync(null, null, null, null, null, null, null);
  }

  /**
   * Retrieves a list of destinations.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param type Destination type. (optional)
   * @param authenticationID Authentication ID used by destinations. (optional)
   * @param transformationID Get the list of destinations used by a transformation. (optional)
   * @param sort Property by which to sort the destinations. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListDestinationsResponse listDestinations(
    Integer itemsPerPage,
    Integer page,
    List<DestinationType> type,
    List<String> authenticationID,
    String transformationID,
    DestinationSortKeys sort,
    OrderKeys order,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(
      listDestinationsAsync(itemsPerPage, page, type, authenticationID, transformationID, sort, order, requestOptions)
    );
  }

  /**
   * Retrieves a list of destinations.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param type Destination type. (optional)
   * @param authenticationID Authentication ID used by destinations. (optional)
   * @param transformationID Get the list of destinations used by a transformation. (optional)
   * @param sort Property by which to sort the destinations. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListDestinationsResponse listDestinations(
    Integer itemsPerPage,
    Integer page,
    List<DestinationType> type,
    List<String> authenticationID,
    String transformationID,
    DestinationSortKeys sort,
    OrderKeys order
  ) throws AlgoliaRuntimeException {
    return this.listDestinations(itemsPerPage, page, type, authenticationID, transformationID, sort, order, null);
  }

  /**
   * Retrieves a list of destinations.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListDestinationsResponse listDestinations(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.listDestinations(null, null, null, null, null, null, null, requestOptions);
  }

  /**
   * Retrieves a list of destinations.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListDestinationsResponse listDestinations() throws AlgoliaRuntimeException {
    return this.listDestinations(null, null, null, null, null, null, null, null);
  }

  /**
   * (asynchronously) Retrieves a list of destinations.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param type Destination type. (optional)
   * @param authenticationID Authentication ID used by destinations. (optional)
   * @param transformationID Get the list of destinations used by a transformation. (optional)
   * @param sort Property by which to sort the destinations. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListDestinationsResponse> listDestinationsAsync(
    Integer itemsPerPage,
    Integer page,
    List<DestinationType> type,
    List<String> authenticationID,
    String transformationID,
    DestinationSortKeys sort,
    OrderKeys order,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    HttpRequest request = HttpRequest.builder()
      .setPath("/1/destinations")
      .setMethod("GET")
      .addQueryParameter("itemsPerPage", itemsPerPage)
      .addQueryParameter("page", page)
      .addQueryParameter("type", type)
      .addQueryParameter("authenticationID", authenticationID)
      .addQueryParameter("transformationID", transformationID)
      .addQueryParameter("sort", sort)
      .addQueryParameter("order", order)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<ListDestinationsResponse>() {});
  }

  /**
   * (asynchronously) Retrieves a list of destinations.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param type Destination type. (optional)
   * @param authenticationID Authentication ID used by destinations. (optional)
   * @param transformationID Get the list of destinations used by a transformation. (optional)
   * @param sort Property by which to sort the destinations. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListDestinationsResponse> listDestinationsAsync(
    Integer itemsPerPage,
    Integer page,
    List<DestinationType> type,
    List<String> authenticationID,
    String transformationID,
    DestinationSortKeys sort,
    OrderKeys order
  ) throws AlgoliaRuntimeException {
    return this.listDestinationsAsync(itemsPerPage, page, type, authenticationID, transformationID, sort, order, null);
  }

  /**
   * (asynchronously) Retrieves a list of destinations.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListDestinationsResponse> listDestinationsAsync(@Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return this.listDestinationsAsync(null, null, null, null, null, null, null, requestOptions);
  }

  /**
   * (asynchronously) Retrieves a list of destinations.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListDestinationsResponse> listDestinationsAsync() throws AlgoliaRuntimeException {
    return this.listDestinationsAsync(null, null, null, null, null, null, null, null);
  }

  /**
   * Retrieves a list of events for a task run, identified by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param status Event status for filtering the list of task runs. (optional)
   * @param type Event type for filtering the list of task runs. (optional)
   * @param sort Property by which to sort the list of task run events. (optional)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param startDate Date and time in RFC 3339 format for the earliest events to retrieve. By
   *     default, the current time minus three hours is used. (optional)
   * @param endDate Date and time in RFC 3339 format for the latest events to retrieve. By default,
   *     the current time is used. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListEventsResponse listEvents(
    @Nonnull String runID,
    Integer itemsPerPage,
    Integer page,
    List<EventStatus> status,
    List<EventType> type,
    EventSortKeys sort,
    OrderKeys order,
    String startDate,
    String endDate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(
      listEventsAsync(runID, itemsPerPage, page, status, type, sort, order, startDate, endDate, requestOptions)
    );
  }

  /**
   * Retrieves a list of events for a task run, identified by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param status Event status for filtering the list of task runs. (optional)
   * @param type Event type for filtering the list of task runs. (optional)
   * @param sort Property by which to sort the list of task run events. (optional)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param startDate Date and time in RFC 3339 format for the earliest events to retrieve. By
   *     default, the current time minus three hours is used. (optional)
   * @param endDate Date and time in RFC 3339 format for the latest events to retrieve. By default,
   *     the current time is used. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListEventsResponse listEvents(
    @Nonnull String runID,
    Integer itemsPerPage,
    Integer page,
    List<EventStatus> status,
    List<EventType> type,
    EventSortKeys sort,
    OrderKeys order,
    String startDate,
    String endDate
  ) throws AlgoliaRuntimeException {
    return this.listEvents(runID, itemsPerPage, page, status, type, sort, order, startDate, endDate, null);
  }

  /**
   * Retrieves a list of events for a task run, identified by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListEventsResponse listEvents(@Nonnull String runID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.listEvents(runID, null, null, null, null, null, null, null, null, requestOptions);
  }

  /**
   * Retrieves a list of events for a task run, identified by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListEventsResponse listEvents(@Nonnull String runID) throws AlgoliaRuntimeException {
    return this.listEvents(runID, null, null, null, null, null, null, null, null, null);
  }

  /**
   * (asynchronously) Retrieves a list of events for a task run, identified by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param status Event status for filtering the list of task runs. (optional)
   * @param type Event type for filtering the list of task runs. (optional)
   * @param sort Property by which to sort the list of task run events. (optional)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param startDate Date and time in RFC 3339 format for the earliest events to retrieve. By
   *     default, the current time minus three hours is used. (optional)
   * @param endDate Date and time in RFC 3339 format for the latest events to retrieve. By default,
   *     the current time is used. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListEventsResponse> listEventsAsync(
    @Nonnull String runID,
    Integer itemsPerPage,
    Integer page,
    List<EventStatus> status,
    List<EventType> type,
    EventSortKeys sort,
    OrderKeys order,
    String startDate,
    String endDate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(runID, "Parameter `runID` is required when calling `listEvents`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/runs/{runID}/events", runID)
      .setMethod("GET")
      .addQueryParameter("itemsPerPage", itemsPerPage)
      .addQueryParameter("page", page)
      .addQueryParameter("status", status)
      .addQueryParameter("type", type)
      .addQueryParameter("sort", sort)
      .addQueryParameter("order", order)
      .addQueryParameter("startDate", startDate)
      .addQueryParameter("endDate", endDate)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<ListEventsResponse>() {});
  }

  /**
   * (asynchronously) Retrieves a list of events for a task run, identified by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param status Event status for filtering the list of task runs. (optional)
   * @param type Event type for filtering the list of task runs. (optional)
   * @param sort Property by which to sort the list of task run events. (optional)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param startDate Date and time in RFC 3339 format for the earliest events to retrieve. By
   *     default, the current time minus three hours is used. (optional)
   * @param endDate Date and time in RFC 3339 format for the latest events to retrieve. By default,
   *     the current time is used. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListEventsResponse> listEventsAsync(
    @Nonnull String runID,
    Integer itemsPerPage,
    Integer page,
    List<EventStatus> status,
    List<EventType> type,
    EventSortKeys sort,
    OrderKeys order,
    String startDate,
    String endDate
  ) throws AlgoliaRuntimeException {
    return this.listEventsAsync(runID, itemsPerPage, page, status, type, sort, order, startDate, endDate, null);
  }

  /**
   * (asynchronously) Retrieves a list of events for a task run, identified by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListEventsResponse> listEventsAsync(@Nonnull String runID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return this.listEventsAsync(runID, null, null, null, null, null, null, null, null, requestOptions);
  }

  /**
   * (asynchronously) Retrieves a list of events for a task run, identified by its ID.
   *
   * @param runID Unique identifier of a task run. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListEventsResponse> listEventsAsync(@Nonnull String runID) throws AlgoliaRuntimeException {
    return this.listEventsAsync(runID, null, null, null, null, null, null, null, null, null);
  }

  /**
   * Retrieve a list of task runs.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param status Run status for filtering the list of task runs. (optional)
   * @param type Run type for filtering the list of task runs. (optional)
   * @param taskID Task ID for filtering the list of task runs. (optional)
   * @param sort Property by which to sort the list of task runs. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param startDate Date in RFC 3339 format for the earliest run to retrieve. By default, the
   *     current day minus seven days is used. (optional)
   * @param endDate Date in RFC 3339 format for the latest run to retrieve. By default, the current
   *     day is used. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public RunListResponse listRuns(
    Integer itemsPerPage,
    Integer page,
    List<RunStatus> status,
    List<RunType> type,
    String taskID,
    RunSortKeys sort,
    OrderKeys order,
    String startDate,
    String endDate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(listRunsAsync(itemsPerPage, page, status, type, taskID, sort, order, startDate, endDate, requestOptions));
  }

  /**
   * Retrieve a list of task runs.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param status Run status for filtering the list of task runs. (optional)
   * @param type Run type for filtering the list of task runs. (optional)
   * @param taskID Task ID for filtering the list of task runs. (optional)
   * @param sort Property by which to sort the list of task runs. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param startDate Date in RFC 3339 format for the earliest run to retrieve. By default, the
   *     current day minus seven days is used. (optional)
   * @param endDate Date in RFC 3339 format for the latest run to retrieve. By default, the current
   *     day is used. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public RunListResponse listRuns(
    Integer itemsPerPage,
    Integer page,
    List<RunStatus> status,
    List<RunType> type,
    String taskID,
    RunSortKeys sort,
    OrderKeys order,
    String startDate,
    String endDate
  ) throws AlgoliaRuntimeException {
    return this.listRuns(itemsPerPage, page, status, type, taskID, sort, order, startDate, endDate, null);
  }

  /**
   * Retrieve a list of task runs.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public RunListResponse listRuns(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.listRuns(null, null, null, null, null, null, null, null, null, requestOptions);
  }

  /**
   * Retrieve a list of task runs.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public RunListResponse listRuns() throws AlgoliaRuntimeException {
    return this.listRuns(null, null, null, null, null, null, null, null, null, null);
  }

  /**
   * (asynchronously) Retrieve a list of task runs.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param status Run status for filtering the list of task runs. (optional)
   * @param type Run type for filtering the list of task runs. (optional)
   * @param taskID Task ID for filtering the list of task runs. (optional)
   * @param sort Property by which to sort the list of task runs. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param startDate Date in RFC 3339 format for the earliest run to retrieve. By default, the
   *     current day minus seven days is used. (optional)
   * @param endDate Date in RFC 3339 format for the latest run to retrieve. By default, the current
   *     day is used. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<RunListResponse> listRunsAsync(
    Integer itemsPerPage,
    Integer page,
    List<RunStatus> status,
    List<RunType> type,
    String taskID,
    RunSortKeys sort,
    OrderKeys order,
    String startDate,
    String endDate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    HttpRequest request = HttpRequest.builder()
      .setPath("/1/runs")
      .setMethod("GET")
      .addQueryParameter("itemsPerPage", itemsPerPage)
      .addQueryParameter("page", page)
      .addQueryParameter("status", status)
      .addQueryParameter("type", type)
      .addQueryParameter("taskID", taskID)
      .addQueryParameter("sort", sort)
      .addQueryParameter("order", order)
      .addQueryParameter("startDate", startDate)
      .addQueryParameter("endDate", endDate)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<RunListResponse>() {});
  }

  /**
   * (asynchronously) Retrieve a list of task runs.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param status Run status for filtering the list of task runs. (optional)
   * @param type Run type for filtering the list of task runs. (optional)
   * @param taskID Task ID for filtering the list of task runs. (optional)
   * @param sort Property by which to sort the list of task runs. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param startDate Date in RFC 3339 format for the earliest run to retrieve. By default, the
   *     current day minus seven days is used. (optional)
   * @param endDate Date in RFC 3339 format for the latest run to retrieve. By default, the current
   *     day is used. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<RunListResponse> listRunsAsync(
    Integer itemsPerPage,
    Integer page,
    List<RunStatus> status,
    List<RunType> type,
    String taskID,
    RunSortKeys sort,
    OrderKeys order,
    String startDate,
    String endDate
  ) throws AlgoliaRuntimeException {
    return this.listRunsAsync(itemsPerPage, page, status, type, taskID, sort, order, startDate, endDate, null);
  }

  /**
   * (asynchronously) Retrieve a list of task runs.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<RunListResponse> listRunsAsync(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.listRunsAsync(null, null, null, null, null, null, null, null, null, requestOptions);
  }

  /**
   * (asynchronously) Retrieve a list of task runs.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<RunListResponse> listRunsAsync() throws AlgoliaRuntimeException {
    return this.listRunsAsync(null, null, null, null, null, null, null, null, null, null);
  }

  /**
   * Retrieves a list of sources.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param type Source type. Some sources require authentication. (optional)
   * @param authenticationID Authentication IDs of the sources to retrieve. 'none' returns sources
   *     that doesn't have an authentication. (optional)
   * @param sort Property by which to sort the list of sources. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListSourcesResponse listSources(
    Integer itemsPerPage,
    Integer page,
    List<SourceType> type,
    List<String> authenticationID,
    SourceSortKeys sort,
    OrderKeys order,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(listSourcesAsync(itemsPerPage, page, type, authenticationID, sort, order, requestOptions));
  }

  /**
   * Retrieves a list of sources.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param type Source type. Some sources require authentication. (optional)
   * @param authenticationID Authentication IDs of the sources to retrieve. 'none' returns sources
   *     that doesn't have an authentication. (optional)
   * @param sort Property by which to sort the list of sources. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListSourcesResponse listSources(
    Integer itemsPerPage,
    Integer page,
    List<SourceType> type,
    List<String> authenticationID,
    SourceSortKeys sort,
    OrderKeys order
  ) throws AlgoliaRuntimeException {
    return this.listSources(itemsPerPage, page, type, authenticationID, sort, order, null);
  }

  /**
   * Retrieves a list of sources.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListSourcesResponse listSources(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.listSources(null, null, null, null, null, null, requestOptions);
  }

  /**
   * Retrieves a list of sources.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListSourcesResponse listSources() throws AlgoliaRuntimeException {
    return this.listSources(null, null, null, null, null, null, null);
  }

  /**
   * (asynchronously) Retrieves a list of sources.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param type Source type. Some sources require authentication. (optional)
   * @param authenticationID Authentication IDs of the sources to retrieve. 'none' returns sources
   *     that doesn't have an authentication. (optional)
   * @param sort Property by which to sort the list of sources. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListSourcesResponse> listSourcesAsync(
    Integer itemsPerPage,
    Integer page,
    List<SourceType> type,
    List<String> authenticationID,
    SourceSortKeys sort,
    OrderKeys order,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    HttpRequest request = HttpRequest.builder()
      .setPath("/1/sources")
      .setMethod("GET")
      .addQueryParameter("itemsPerPage", itemsPerPage)
      .addQueryParameter("page", page)
      .addQueryParameter("type", type)
      .addQueryParameter("authenticationID", authenticationID)
      .addQueryParameter("sort", sort)
      .addQueryParameter("order", order)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<ListSourcesResponse>() {});
  }

  /**
   * (asynchronously) Retrieves a list of sources.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param type Source type. Some sources require authentication. (optional)
   * @param authenticationID Authentication IDs of the sources to retrieve. 'none' returns sources
   *     that doesn't have an authentication. (optional)
   * @param sort Property by which to sort the list of sources. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListSourcesResponse> listSourcesAsync(
    Integer itemsPerPage,
    Integer page,
    List<SourceType> type,
    List<String> authenticationID,
    SourceSortKeys sort,
    OrderKeys order
  ) throws AlgoliaRuntimeException {
    return this.listSourcesAsync(itemsPerPage, page, type, authenticationID, sort, order, null);
  }

  /**
   * (asynchronously) Retrieves a list of sources.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListSourcesResponse> listSourcesAsync(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.listSourcesAsync(null, null, null, null, null, null, requestOptions);
  }

  /**
   * (asynchronously) Retrieves a list of sources.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListSourcesResponse> listSourcesAsync() throws AlgoliaRuntimeException {
    return this.listSourcesAsync(null, null, null, null, null, null, null);
  }

  /**
   * Retrieves a list of tasks.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param action Actions for filtering the list of tasks. (optional)
   * @param enabled Whether to filter the list of tasks by the `enabled` status. (optional)
   * @param sourceID Source IDs for filtering the list of tasks. (optional)
   * @param sourceType Filters the tasks with the specified source type. (optional)
   * @param destinationID Destination IDs for filtering the list of tasks. (optional)
   * @param triggerType Type of task trigger for filtering the list of tasks. (optional)
   * @param withEmailNotifications If specified, the response only includes tasks with
   *     notifications.email.enabled set to this value. (optional)
   * @param sort Property by which to sort the list of tasks. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListTasksResponse listTasks(
    Integer itemsPerPage,
    Integer page,
    List<ActionType> action,
    Boolean enabled,
    List<String> sourceID,
    List<SourceType> sourceType,
    List<String> destinationID,
    List<TriggerType> triggerType,
    Boolean withEmailNotifications,
    TaskSortKeys sort,
    OrderKeys order,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(
      listTasksAsync(
        itemsPerPage,
        page,
        action,
        enabled,
        sourceID,
        sourceType,
        destinationID,
        triggerType,
        withEmailNotifications,
        sort,
        order,
        requestOptions
      )
    );
  }

  /**
   * Retrieves a list of tasks.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param action Actions for filtering the list of tasks. (optional)
   * @param enabled Whether to filter the list of tasks by the `enabled` status. (optional)
   * @param sourceID Source IDs for filtering the list of tasks. (optional)
   * @param sourceType Filters the tasks with the specified source type. (optional)
   * @param destinationID Destination IDs for filtering the list of tasks. (optional)
   * @param triggerType Type of task trigger for filtering the list of tasks. (optional)
   * @param withEmailNotifications If specified, the response only includes tasks with
   *     notifications.email.enabled set to this value. (optional)
   * @param sort Property by which to sort the list of tasks. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListTasksResponse listTasks(
    Integer itemsPerPage,
    Integer page,
    List<ActionType> action,
    Boolean enabled,
    List<String> sourceID,
    List<SourceType> sourceType,
    List<String> destinationID,
    List<TriggerType> triggerType,
    Boolean withEmailNotifications,
    TaskSortKeys sort,
    OrderKeys order
  ) throws AlgoliaRuntimeException {
    return this.listTasks(
        itemsPerPage,
        page,
        action,
        enabled,
        sourceID,
        sourceType,
        destinationID,
        triggerType,
        withEmailNotifications,
        sort,
        order,
        null
      );
  }

  /**
   * Retrieves a list of tasks.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListTasksResponse listTasks(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.listTasks(null, null, null, null, null, null, null, null, null, null, null, requestOptions);
  }

  /**
   * Retrieves a list of tasks.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListTasksResponse listTasks() throws AlgoliaRuntimeException {
    return this.listTasks(null, null, null, null, null, null, null, null, null, null, null, null);
  }

  /**
   * (asynchronously) Retrieves a list of tasks.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param action Actions for filtering the list of tasks. (optional)
   * @param enabled Whether to filter the list of tasks by the `enabled` status. (optional)
   * @param sourceID Source IDs for filtering the list of tasks. (optional)
   * @param sourceType Filters the tasks with the specified source type. (optional)
   * @param destinationID Destination IDs for filtering the list of tasks. (optional)
   * @param triggerType Type of task trigger for filtering the list of tasks. (optional)
   * @param withEmailNotifications If specified, the response only includes tasks with
   *     notifications.email.enabled set to this value. (optional)
   * @param sort Property by which to sort the list of tasks. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListTasksResponse> listTasksAsync(
    Integer itemsPerPage,
    Integer page,
    List<ActionType> action,
    Boolean enabled,
    List<String> sourceID,
    List<SourceType> sourceType,
    List<String> destinationID,
    List<TriggerType> triggerType,
    Boolean withEmailNotifications,
    TaskSortKeys sort,
    OrderKeys order,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    HttpRequest request = HttpRequest.builder()
      .setPath("/2/tasks")
      .setMethod("GET")
      .addQueryParameter("itemsPerPage", itemsPerPage)
      .addQueryParameter("page", page)
      .addQueryParameter("action", action)
      .addQueryParameter("enabled", enabled)
      .addQueryParameter("sourceID", sourceID)
      .addQueryParameter("sourceType", sourceType)
      .addQueryParameter("destinationID", destinationID)
      .addQueryParameter("triggerType", triggerType)
      .addQueryParameter("withEmailNotifications", withEmailNotifications)
      .addQueryParameter("sort", sort)
      .addQueryParameter("order", order)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<ListTasksResponse>() {});
  }

  /**
   * (asynchronously) Retrieves a list of tasks.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param action Actions for filtering the list of tasks. (optional)
   * @param enabled Whether to filter the list of tasks by the `enabled` status. (optional)
   * @param sourceID Source IDs for filtering the list of tasks. (optional)
   * @param sourceType Filters the tasks with the specified source type. (optional)
   * @param destinationID Destination IDs for filtering the list of tasks. (optional)
   * @param triggerType Type of task trigger for filtering the list of tasks. (optional)
   * @param withEmailNotifications If specified, the response only includes tasks with
   *     notifications.email.enabled set to this value. (optional)
   * @param sort Property by which to sort the list of tasks. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListTasksResponse> listTasksAsync(
    Integer itemsPerPage,
    Integer page,
    List<ActionType> action,
    Boolean enabled,
    List<String> sourceID,
    List<SourceType> sourceType,
    List<String> destinationID,
    List<TriggerType> triggerType,
    Boolean withEmailNotifications,
    TaskSortKeys sort,
    OrderKeys order
  ) throws AlgoliaRuntimeException {
    return this.listTasksAsync(
        itemsPerPage,
        page,
        action,
        enabled,
        sourceID,
        sourceType,
        destinationID,
        triggerType,
        withEmailNotifications,
        sort,
        order,
        null
      );
  }

  /**
   * (asynchronously) Retrieves a list of tasks.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListTasksResponse> listTasksAsync(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.listTasksAsync(null, null, null, null, null, null, null, null, null, null, null, requestOptions);
  }

  /**
   * (asynchronously) Retrieves a list of tasks.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListTasksResponse> listTasksAsync() throws AlgoliaRuntimeException {
    return this.listTasksAsync(null, null, null, null, null, null, null, null, null, null, null, null);
  }

  /**
   * Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param action Actions for filtering the list of tasks. (optional)
   * @param enabled Whether to filter the list of tasks by the `enabled` status. (optional)
   * @param sourceID Source IDs for filtering the list of tasks. (optional)
   * @param destinationID Destination IDs for filtering the list of tasks. (optional)
   * @param triggerType Type of task trigger for filtering the list of tasks. (optional)
   * @param sort Property by which to sort the list of tasks. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public ListTasksResponseV1 listTasksV1(
    Integer itemsPerPage,
    Integer page,
    List<ActionType> action,
    Boolean enabled,
    List<String> sourceID,
    List<String> destinationID,
    List<TriggerType> triggerType,
    TaskSortKeys sort,
    OrderKeys order,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(
      listTasksV1Async(itemsPerPage, page, action, enabled, sourceID, destinationID, triggerType, sort, order, requestOptions)
    );
  }

  /**
   * Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param action Actions for filtering the list of tasks. (optional)
   * @param enabled Whether to filter the list of tasks by the `enabled` status. (optional)
   * @param sourceID Source IDs for filtering the list of tasks. (optional)
   * @param destinationID Destination IDs for filtering the list of tasks. (optional)
   * @param triggerType Type of task trigger for filtering the list of tasks. (optional)
   * @param sort Property by which to sort the list of tasks. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public ListTasksResponseV1 listTasksV1(
    Integer itemsPerPage,
    Integer page,
    List<ActionType> action,
    Boolean enabled,
    List<String> sourceID,
    List<String> destinationID,
    List<TriggerType> triggerType,
    TaskSortKeys sort,
    OrderKeys order
  ) throws AlgoliaRuntimeException {
    return this.listTasksV1(itemsPerPage, page, action, enabled, sourceID, destinationID, triggerType, sort, order, null);
  }

  /**
   * Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListTasksResponseV1 listTasksV1(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.listTasksV1(null, null, null, null, null, null, null, null, null, requestOptions);
  }

  /**
   * Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListTasksResponseV1 listTasksV1() throws AlgoliaRuntimeException {
    return this.listTasksV1(null, null, null, null, null, null, null, null, null, null);
  }

  /**
   * (asynchronously) Retrieves a list of tasks using the v1 endpoint, please use `getTasks`
   * instead.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param action Actions for filtering the list of tasks. (optional)
   * @param enabled Whether to filter the list of tasks by the `enabled` status. (optional)
   * @param sourceID Source IDs for filtering the list of tasks. (optional)
   * @param destinationID Destination IDs for filtering the list of tasks. (optional)
   * @param triggerType Type of task trigger for filtering the list of tasks. (optional)
   * @param sort Property by which to sort the list of tasks. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<ListTasksResponseV1> listTasksV1Async(
    Integer itemsPerPage,
    Integer page,
    List<ActionType> action,
    Boolean enabled,
    List<String> sourceID,
    List<String> destinationID,
    List<TriggerType> triggerType,
    TaskSortKeys sort,
    OrderKeys order,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    HttpRequest request = HttpRequest.builder()
      .setPath("/1/tasks")
      .setMethod("GET")
      .addQueryParameter("itemsPerPage", itemsPerPage)
      .addQueryParameter("page", page)
      .addQueryParameter("action", action)
      .addQueryParameter("enabled", enabled)
      .addQueryParameter("sourceID", sourceID)
      .addQueryParameter("destinationID", destinationID)
      .addQueryParameter("triggerType", triggerType)
      .addQueryParameter("sort", sort)
      .addQueryParameter("order", order)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<ListTasksResponseV1>() {});
  }

  /**
   * (asynchronously) Retrieves a list of tasks using the v1 endpoint, please use `getTasks`
   * instead.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param action Actions for filtering the list of tasks. (optional)
   * @param enabled Whether to filter the list of tasks by the `enabled` status. (optional)
   * @param sourceID Source IDs for filtering the list of tasks. (optional)
   * @param destinationID Destination IDs for filtering the list of tasks. (optional)
   * @param triggerType Type of task trigger for filtering the list of tasks. (optional)
   * @param sort Property by which to sort the list of tasks. (optional, default to createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<ListTasksResponseV1> listTasksV1Async(
    Integer itemsPerPage,
    Integer page,
    List<ActionType> action,
    Boolean enabled,
    List<String> sourceID,
    List<String> destinationID,
    List<TriggerType> triggerType,
    TaskSortKeys sort,
    OrderKeys order
  ) throws AlgoliaRuntimeException {
    return this.listTasksV1Async(itemsPerPage, page, action, enabled, sourceID, destinationID, triggerType, sort, order, null);
  }

  /**
   * (asynchronously) Retrieves a list of tasks using the v1 endpoint, please use `getTasks`
   * instead.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListTasksResponseV1> listTasksV1Async(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.listTasksV1Async(null, null, null, null, null, null, null, null, null, requestOptions);
  }

  /**
   * (asynchronously) Retrieves a list of tasks using the v1 endpoint, please use `getTasks`
   * instead.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListTasksResponseV1> listTasksV1Async() throws AlgoliaRuntimeException {
    return this.listTasksV1Async(null, null, null, null, null, null, null, null, null, null);
  }

  /**
   * Retrieves a list of transformations.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param sort Property by which to sort the list of transformations. (optional, default to
   *     createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListTransformationsResponse listTransformations(
    Integer itemsPerPage,
    Integer page,
    TransformationSortKeys sort,
    OrderKeys order,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(listTransformationsAsync(itemsPerPage, page, sort, order, requestOptions));
  }

  /**
   * Retrieves a list of transformations.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param sort Property by which to sort the list of transformations. (optional, default to
   *     createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListTransformationsResponse listTransformations(Integer itemsPerPage, Integer page, TransformationSortKeys sort, OrderKeys order)
    throws AlgoliaRuntimeException {
    return this.listTransformations(itemsPerPage, page, sort, order, null);
  }

  /**
   * Retrieves a list of transformations.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListTransformationsResponse listTransformations(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.listTransformations(null, null, null, null, requestOptions);
  }

  /**
   * Retrieves a list of transformations.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public ListTransformationsResponse listTransformations() throws AlgoliaRuntimeException {
    return this.listTransformations(null, null, null, null, null);
  }

  /**
   * (asynchronously) Retrieves a list of transformations.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param sort Property by which to sort the list of transformations. (optional, default to
   *     createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListTransformationsResponse> listTransformationsAsync(
    Integer itemsPerPage,
    Integer page,
    TransformationSortKeys sort,
    OrderKeys order,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    HttpRequest request = HttpRequest.builder()
      .setPath("/1/transformations")
      .setMethod("GET")
      .addQueryParameter("itemsPerPage", itemsPerPage)
      .addQueryParameter("page", page)
      .addQueryParameter("sort", sort)
      .addQueryParameter("order", order)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<ListTransformationsResponse>() {});
  }

  /**
   * (asynchronously) Retrieves a list of transformations.
   *
   * @param itemsPerPage Number of items per page. (optional, default to 10)
   * @param page Page number of the paginated API response. (optional)
   * @param sort Property by which to sort the list of transformations. (optional, default to
   *     createdAt)
   * @param order Sort order of the response, ascending or descending. (optional, default to desc)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListTransformationsResponse> listTransformationsAsync(
    Integer itemsPerPage,
    Integer page,
    TransformationSortKeys sort,
    OrderKeys order
  ) throws AlgoliaRuntimeException {
    return this.listTransformationsAsync(itemsPerPage, page, sort, order, null);
  }

  /**
   * (asynchronously) Retrieves a list of transformations.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListTransformationsResponse> listTransformationsAsync(@Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return this.listTransformationsAsync(null, null, null, null, requestOptions);
  }

  /**
   * (asynchronously) Retrieves a list of transformations.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<ListTransformationsResponse> listTransformationsAsync() throws AlgoliaRuntimeException {
    return this.listTransformationsAsync(null, null, null, null, null);
  }

  /**
   * Pushes records through the Pipeline, directly to an index. You can make the call synchronous by
   * providing the `watch` parameter, for asynchronous calls, you can use the observability
   * endpoints and/or debugger dashboard to see the status of your task. If you want to leverage the
   * [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `pushTask`,
   * but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error
   * will be returned.
   *
   * @param indexName Name of the index on which to perform the operation. (required)
   * @param pushTaskPayload (required)
   * @param watch When provided, the push operation will be synchronous and the API will wait for
   *     the ingestion to be finished before responding. (optional)
   * @param referenceIndexName This is required when targeting an index that does not have a push
   *     connector setup (e.g. a tmp index), but you wish to attach another index's transformation
   *     to it (e.g. the source index name). (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse push(
    @Nonnull String indexName,
    @Nonnull PushTaskPayload pushTaskPayload,
    Boolean watch,
    String referenceIndexName,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(pushAsync(indexName, pushTaskPayload, watch, referenceIndexName, requestOptions));
  }

  /**
   * Pushes records through the Pipeline, directly to an index. You can make the call synchronous by
   * providing the `watch` parameter, for asynchronous calls, you can use the observability
   * endpoints and/or debugger dashboard to see the status of your task. If you want to leverage the
   * [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `pushTask`,
   * but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error
   * will be returned.
   *
   * @param indexName Name of the index on which to perform the operation. (required)
   * @param pushTaskPayload (required)
   * @param watch When provided, the push operation will be synchronous and the API will wait for
   *     the ingestion to be finished before responding. (optional)
   * @param referenceIndexName This is required when targeting an index that does not have a push
   *     connector setup (e.g. a tmp index), but you wish to attach another index's transformation
   *     to it (e.g. the source index name). (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse push(@Nonnull String indexName, @Nonnull PushTaskPayload pushTaskPayload, Boolean watch, String referenceIndexName)
    throws AlgoliaRuntimeException {
    return this.push(indexName, pushTaskPayload, watch, referenceIndexName, null);
  }

  /**
   * Pushes records through the Pipeline, directly to an index. You can make the call synchronous by
   * providing the `watch` parameter, for asynchronous calls, you can use the observability
   * endpoints and/or debugger dashboard to see the status of your task. If you want to leverage the
   * [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `pushTask`,
   * but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error
   * will be returned.
   *
   * @param indexName Name of the index on which to perform the operation. (required)
   * @param pushTaskPayload (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse push(@Nonnull String indexName, @Nonnull PushTaskPayload pushTaskPayload, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return this.push(indexName, pushTaskPayload, null, null, requestOptions);
  }

  /**
   * Pushes records through the Pipeline, directly to an index. You can make the call synchronous by
   * providing the `watch` parameter, for asynchronous calls, you can use the observability
   * endpoints and/or debugger dashboard to see the status of your task. If you want to leverage the
   * [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `pushTask`,
   * but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error
   * will be returned.
   *
   * @param indexName Name of the index on which to perform the operation. (required)
   * @param pushTaskPayload (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse push(@Nonnull String indexName, @Nonnull PushTaskPayload pushTaskPayload) throws AlgoliaRuntimeException {
    return this.push(indexName, pushTaskPayload, null, null, null);
  }

  /**
   * (asynchronously) Pushes records through the Pipeline, directly to an index. You can make the
   * call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the
   * observability endpoints and/or debugger dashboard to see the status of your task. If you want
   * to leverage the [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `pushTask`,
   * but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error
   * will be returned.
   *
   * @param indexName Name of the index on which to perform the operation. (required)
   * @param pushTaskPayload (required)
   * @param watch When provided, the push operation will be synchronous and the API will wait for
   *     the ingestion to be finished before responding. (optional)
   * @param referenceIndexName This is required when targeting an index that does not have a push
   *     connector setup (e.g. a tmp index), but you wish to attach another index's transformation
   *     to it (e.g. the source index name). (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> pushAsync(
    @Nonnull String indexName,
    @Nonnull PushTaskPayload pushTaskPayload,
    Boolean watch,
    String referenceIndexName,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(indexName, "Parameter `indexName` is required when calling `push`.");

    Parameters.requireNonNull(pushTaskPayload, "Parameter `pushTaskPayload` is required when calling `push`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/push/{indexName}", indexName)
      .setMethod("POST")
      .setBody(pushTaskPayload)
      .addQueryParameter("watch", watch)
      .addQueryParameter("referenceIndexName", referenceIndexName)
      .build();
    return executeAsync(
      request,
      new RequestOptions()
        .setReadTimeout(Duration.ofMillis(180000L))
        .setWriteTimeout(Duration.ofMillis(180000L))
        .setConnectTimeout(Duration.ofMillis(180000L))
        .mergeRight(requestOptions),
      new TypeReference<WatchResponse>() {}
    );
  }

  /**
   * (asynchronously) Pushes records through the Pipeline, directly to an index. You can make the
   * call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the
   * observability endpoints and/or debugger dashboard to see the status of your task. If you want
   * to leverage the [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `pushTask`,
   * but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error
   * will be returned.
   *
   * @param indexName Name of the index on which to perform the operation. (required)
   * @param pushTaskPayload (required)
   * @param watch When provided, the push operation will be synchronous and the API will wait for
   *     the ingestion to be finished before responding. (optional)
   * @param referenceIndexName This is required when targeting an index that does not have a push
   *     connector setup (e.g. a tmp index), but you wish to attach another index's transformation
   *     to it (e.g. the source index name). (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> pushAsync(
    @Nonnull String indexName,
    @Nonnull PushTaskPayload pushTaskPayload,
    Boolean watch,
    String referenceIndexName
  ) throws AlgoliaRuntimeException {
    return this.pushAsync(indexName, pushTaskPayload, watch, referenceIndexName, null);
  }

  /**
   * (asynchronously) Pushes records through the Pipeline, directly to an index. You can make the
   * call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the
   * observability endpoints and/or debugger dashboard to see the status of your task. If you want
   * to leverage the [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `pushTask`,
   * but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error
   * will be returned.
   *
   * @param indexName Name of the index on which to perform the operation. (required)
   * @param pushTaskPayload (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> pushAsync(
    @Nonnull String indexName,
    @Nonnull PushTaskPayload pushTaskPayload,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return this.pushAsync(indexName, pushTaskPayload, null, null, requestOptions);
  }

  /**
   * (asynchronously) Pushes records through the Pipeline, directly to an index. You can make the
   * call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the
   * observability endpoints and/or debugger dashboard to see the status of your task. If you want
   * to leverage the [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `pushTask`,
   * but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error
   * will be returned.
   *
   * @param indexName Name of the index on which to perform the operation. (required)
   * @param pushTaskPayload (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> pushAsync(@Nonnull String indexName, @Nonnull PushTaskPayload pushTaskPayload)
    throws AlgoliaRuntimeException {
    return this.pushAsync(indexName, pushTaskPayload, null, null, null);
  }

  /**
   * Pushes records through the Pipeline, directly to an index. You can make the call synchronous by
   * providing the `watch` parameter, for asynchronous calls, you can use the observability
   * endpoints and/or debugger dashboard to see the status of your task. If you want to leverage the
   * [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `push`, but
   * requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target
   * the same `indexName`.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param pushTaskPayload (required)
   * @param watch When provided, the push operation will be synchronous and the API will wait for
   *     the ingestion to be finished before responding. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse pushTask(
    @Nonnull String taskID,
    @Nonnull PushTaskPayload pushTaskPayload,
    Boolean watch,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(pushTaskAsync(taskID, pushTaskPayload, watch, requestOptions));
  }

  /**
   * Pushes records through the Pipeline, directly to an index. You can make the call synchronous by
   * providing the `watch` parameter, for asynchronous calls, you can use the observability
   * endpoints and/or debugger dashboard to see the status of your task. If you want to leverage the
   * [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `push`, but
   * requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target
   * the same `indexName`.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param pushTaskPayload (required)
   * @param watch When provided, the push operation will be synchronous and the API will wait for
   *     the ingestion to be finished before responding. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse pushTask(@Nonnull String taskID, @Nonnull PushTaskPayload pushTaskPayload, Boolean watch)
    throws AlgoliaRuntimeException {
    return this.pushTask(taskID, pushTaskPayload, watch, null);
  }

  /**
   * Pushes records through the Pipeline, directly to an index. You can make the call synchronous by
   * providing the `watch` parameter, for asynchronous calls, you can use the observability
   * endpoints and/or debugger dashboard to see the status of your task. If you want to leverage the
   * [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `push`, but
   * requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target
   * the same `indexName`.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param pushTaskPayload (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse pushTask(@Nonnull String taskID, @Nonnull PushTaskPayload pushTaskPayload, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return this.pushTask(taskID, pushTaskPayload, null, requestOptions);
  }

  /**
   * Pushes records through the Pipeline, directly to an index. You can make the call synchronous by
   * providing the `watch` parameter, for asynchronous calls, you can use the observability
   * endpoints and/or debugger dashboard to see the status of your task. If you want to leverage the
   * [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `push`, but
   * requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target
   * the same `indexName`.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param pushTaskPayload (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse pushTask(@Nonnull String taskID, @Nonnull PushTaskPayload pushTaskPayload) throws AlgoliaRuntimeException {
    return this.pushTask(taskID, pushTaskPayload, null, null);
  }

  /**
   * (asynchronously) Pushes records through the Pipeline, directly to an index. You can make the
   * call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the
   * observability endpoints and/or debugger dashboard to see the status of your task. If you want
   * to leverage the [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `push`, but
   * requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target
   * the same `indexName`.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param pushTaskPayload (required)
   * @param watch When provided, the push operation will be synchronous and the API will wait for
   *     the ingestion to be finished before responding. (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> pushTaskAsync(
    @Nonnull String taskID,
    @Nonnull PushTaskPayload pushTaskPayload,
    Boolean watch,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `pushTask`.");

    Parameters.requireNonNull(pushTaskPayload, "Parameter `pushTaskPayload` is required when calling `pushTask`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/2/tasks/{taskID}/push", taskID)
      .setMethod("POST")
      .setBody(pushTaskPayload)
      .addQueryParameter("watch", watch)
      .build();
    return executeAsync(
      request,
      new RequestOptions()
        .setReadTimeout(Duration.ofMillis(180000L))
        .setWriteTimeout(Duration.ofMillis(180000L))
        .setConnectTimeout(Duration.ofMillis(180000L))
        .mergeRight(requestOptions),
      new TypeReference<WatchResponse>() {}
    );
  }

  /**
   * (asynchronously) Pushes records through the Pipeline, directly to an index. You can make the
   * call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the
   * observability endpoints and/or debugger dashboard to see the status of your task. If you want
   * to leverage the [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `push`, but
   * requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target
   * the same `indexName`.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param pushTaskPayload (required)
   * @param watch When provided, the push operation will be synchronous and the API will wait for
   *     the ingestion to be finished before responding. (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> pushTaskAsync(@Nonnull String taskID, @Nonnull PushTaskPayload pushTaskPayload, Boolean watch)
    throws AlgoliaRuntimeException {
    return this.pushTaskAsync(taskID, pushTaskPayload, watch, null);
  }

  /**
   * (asynchronously) Pushes records through the Pipeline, directly to an index. You can make the
   * call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the
   * observability endpoints and/or debugger dashboard to see the status of your task. If you want
   * to leverage the [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `push`, but
   * requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target
   * the same `indexName`.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param pushTaskPayload (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> pushTaskAsync(
    @Nonnull String taskID,
    @Nonnull PushTaskPayload pushTaskPayload,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return this.pushTaskAsync(taskID, pushTaskPayload, null, requestOptions);
  }

  /**
   * (asynchronously) Pushes records through the Pipeline, directly to an index. You can make the
   * call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the
   * observability endpoints and/or debugger dashboard to see the status of your task. If you want
   * to leverage the [pre-indexing data
   * transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/),
   * this is the recommended way of ingesting your records. This method is similar to `push`, but
   * requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target
   * the same `indexName`.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param pushTaskPayload (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> pushTaskAsync(@Nonnull String taskID, @Nonnull PushTaskPayload pushTaskPayload)
    throws AlgoliaRuntimeException {
    return this.pushTaskAsync(taskID, pushTaskPayload, null, null);
  }

  /**
   * Runs all tasks linked to a source, only available for Shopify, BigCommerce and commercetools
   * sources. Creates one run per task.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param runSourcePayload (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public RunSourceResponse runSource(@Nonnull String sourceID, RunSourcePayload runSourcePayload, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(runSourceAsync(sourceID, runSourcePayload, requestOptions));
  }

  /**
   * Runs all tasks linked to a source, only available for Shopify, BigCommerce and commercetools
   * sources. Creates one run per task.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param runSourcePayload (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public RunSourceResponse runSource(@Nonnull String sourceID, RunSourcePayload runSourcePayload) throws AlgoliaRuntimeException {
    return this.runSource(sourceID, runSourcePayload, null);
  }

  /**
   * Runs all tasks linked to a source, only available for Shopify, BigCommerce and commercetools
   * sources. Creates one run per task.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public RunSourceResponse runSource(@Nonnull String sourceID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.runSource(sourceID, null, requestOptions);
  }

  /**
   * Runs all tasks linked to a source, only available for Shopify, BigCommerce and commercetools
   * sources. Creates one run per task.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public RunSourceResponse runSource(@Nonnull String sourceID) throws AlgoliaRuntimeException {
    return this.runSource(sourceID, null, null);
  }

  /**
   * (asynchronously) Runs all tasks linked to a source, only available for Shopify, BigCommerce and
   * commercetools sources. Creates one run per task.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param runSourcePayload (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<RunSourceResponse> runSourceAsync(
    @Nonnull String sourceID,
    RunSourcePayload runSourcePayload,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(sourceID, "Parameter `sourceID` is required when calling `runSource`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/sources/{sourceID}/run", sourceID)
      .setMethod("POST")
      .setBody(runSourcePayload)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<RunSourceResponse>() {});
  }

  /**
   * (asynchronously) Runs all tasks linked to a source, only available for Shopify, BigCommerce and
   * commercetools sources. Creates one run per task.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param runSourcePayload (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<RunSourceResponse> runSourceAsync(@Nonnull String sourceID, RunSourcePayload runSourcePayload)
    throws AlgoliaRuntimeException {
    return this.runSourceAsync(sourceID, runSourcePayload, null);
  }

  /**
   * (asynchronously) Runs all tasks linked to a source, only available for Shopify, BigCommerce and
   * commercetools sources. Creates one run per task.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<RunSourceResponse> runSourceAsync(@Nonnull String sourceID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return this.runSourceAsync(sourceID, null, requestOptions);
  }

  /**
   * (asynchronously) Runs all tasks linked to a source, only available for Shopify, BigCommerce and
   * commercetools sources. Creates one run per task.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<RunSourceResponse> runSourceAsync(@Nonnull String sourceID) throws AlgoliaRuntimeException {
    return this.runSourceAsync(sourceID, null, null);
  }

  /**
   * Runs a task. You can check the status of task runs with the observability endpoints.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public RunResponse runTask(@Nonnull String taskID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(runTaskAsync(taskID, requestOptions));
  }

  /**
   * Runs a task. You can check the status of task runs with the observability endpoints.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public RunResponse runTask(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.runTask(taskID, null);
  }

  /**
   * (asynchronously) Runs a task. You can check the status of task runs with the observability
   * endpoints.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<RunResponse> runTaskAsync(@Nonnull String taskID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `runTask`.");

    HttpRequest request = HttpRequest.builder().setPath("/2/tasks/{taskID}/run", taskID).setMethod("POST").build();

    return executeAsync(request, requestOptions, new TypeReference<RunResponse>() {});
  }

  /**
   * (asynchronously) Runs a task. You can check the status of task runs with the observability
   * endpoints.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<RunResponse> runTaskAsync(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.runTaskAsync(taskID, null);
  }

  /**
   * Runs a task using the v1 endpoint, please use `runTask` instead. You can check the status of
   * task runs with the observability endpoints.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public RunResponse runTaskV1(@Nonnull String taskID, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(runTaskV1Async(taskID, requestOptions));
  }

  /**
   * Runs a task using the v1 endpoint, please use `runTask` instead. You can check the status of
   * task runs with the observability endpoints.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public RunResponse runTaskV1(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.runTaskV1(taskID, null);
  }

  /**
   * (asynchronously) Runs a task using the v1 endpoint, please use `runTask` instead. You can check
   * the status of task runs with the observability endpoints.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<RunResponse> runTaskV1Async(@Nonnull String taskID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `runTaskV1`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/tasks/{taskID}/run", taskID).setMethod("POST").build();

    return executeAsync(request, requestOptions, new TypeReference<RunResponse>() {});
  }

  /**
   * (asynchronously) Runs a task using the v1 endpoint, please use `runTask` instead. You can check
   * the status of task runs with the observability endpoints.
   *
   * @param taskID Unique identifier of a task. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<RunResponse> runTaskV1Async(@Nonnull String taskID) throws AlgoliaRuntimeException {
    return this.runTaskV1Async(taskID, null);
  }

  /**
   * Searches for authentication resources.
   *
   * @param authenticationSearch (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public List<Authentication> searchAuthentications(
    @Nonnull AuthenticationSearch authenticationSearch,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(searchAuthenticationsAsync(authenticationSearch, requestOptions));
  }

  /**
   * Searches for authentication resources.
   *
   * @param authenticationSearch (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public List<Authentication> searchAuthentications(@Nonnull AuthenticationSearch authenticationSearch) throws AlgoliaRuntimeException {
    return this.searchAuthentications(authenticationSearch, null);
  }

  /**
   * (asynchronously) Searches for authentication resources.
   *
   * @param authenticationSearch (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<List<Authentication>> searchAuthenticationsAsync(
    @Nonnull AuthenticationSearch authenticationSearch,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(authenticationSearch, "Parameter `authenticationSearch` is required when calling `searchAuthentications`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/authentications/search")
      .setMethod("POST")
      .setBody(authenticationSearch)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<List<Authentication>>() {});
  }

  /**
   * (asynchronously) Searches for authentication resources.
   *
   * @param authenticationSearch (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<List<Authentication>> searchAuthenticationsAsync(@Nonnull AuthenticationSearch authenticationSearch)
    throws AlgoliaRuntimeException {
    return this.searchAuthenticationsAsync(authenticationSearch, null);
  }

  /**
   * Searches for destinations.
   *
   * @param destinationSearch (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public List<Destination> searchDestinations(@Nonnull DestinationSearch destinationSearch, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(searchDestinationsAsync(destinationSearch, requestOptions));
  }

  /**
   * Searches for destinations.
   *
   * @param destinationSearch (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public List<Destination> searchDestinations(@Nonnull DestinationSearch destinationSearch) throws AlgoliaRuntimeException {
    return this.searchDestinations(destinationSearch, null);
  }

  /**
   * (asynchronously) Searches for destinations.
   *
   * @param destinationSearch (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<List<Destination>> searchDestinationsAsync(
    @Nonnull DestinationSearch destinationSearch,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(destinationSearch, "Parameter `destinationSearch` is required when calling `searchDestinations`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/destinations/search").setMethod("POST").setBody(destinationSearch).build();
    return executeAsync(request, requestOptions, new TypeReference<List<Destination>>() {});
  }

  /**
   * (asynchronously) Searches for destinations.
   *
   * @param destinationSearch (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<List<Destination>> searchDestinationsAsync(@Nonnull DestinationSearch destinationSearch)
    throws AlgoliaRuntimeException {
    return this.searchDestinationsAsync(destinationSearch, null);
  }

  /**
   * Searches for sources.
   *
   * @param sourceSearch (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public List<Source> searchSources(@Nonnull SourceSearch sourceSearch, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(searchSourcesAsync(sourceSearch, requestOptions));
  }

  /**
   * Searches for sources.
   *
   * @param sourceSearch (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public List<Source> searchSources(@Nonnull SourceSearch sourceSearch) throws AlgoliaRuntimeException {
    return this.searchSources(sourceSearch, null);
  }

  /**
   * (asynchronously) Searches for sources.
   *
   * @param sourceSearch (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<List<Source>> searchSourcesAsync(@Nonnull SourceSearch sourceSearch, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(sourceSearch, "Parameter `sourceSearch` is required when calling `searchSources`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/sources/search").setMethod("POST").setBody(sourceSearch).build();
    return executeAsync(request, requestOptions, new TypeReference<List<Source>>() {});
  }

  /**
   * (asynchronously) Searches for sources.
   *
   * @param sourceSearch (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<List<Source>> searchSourcesAsync(@Nonnull SourceSearch sourceSearch) throws AlgoliaRuntimeException {
    return this.searchSourcesAsync(sourceSearch, null);
  }

  /**
   * Searches for tasks.
   *
   * @param taskSearch (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public List<Task> searchTasks(@Nonnull TaskSearch taskSearch, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(searchTasksAsync(taskSearch, requestOptions));
  }

  /**
   * Searches for tasks.
   *
   * @param taskSearch (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public List<Task> searchTasks(@Nonnull TaskSearch taskSearch) throws AlgoliaRuntimeException {
    return this.searchTasks(taskSearch, null);
  }

  /**
   * (asynchronously) Searches for tasks.
   *
   * @param taskSearch (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<List<Task>> searchTasksAsync(@Nonnull TaskSearch taskSearch, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskSearch, "Parameter `taskSearch` is required when calling `searchTasks`.");

    HttpRequest request = HttpRequest.builder().setPath("/2/tasks/search").setMethod("POST").setBody(taskSearch).build();
    return executeAsync(request, requestOptions, new TypeReference<List<Task>>() {});
  }

  /**
   * (asynchronously) Searches for tasks.
   *
   * @param taskSearch (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<List<Task>> searchTasksAsync(@Nonnull TaskSearch taskSearch) throws AlgoliaRuntimeException {
    return this.searchTasksAsync(taskSearch, null);
  }

  /**
   * Searches for tasks using the v1 endpoint, please use `searchTasks` instead.
   *
   * @param taskSearch (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public List<TaskV1> searchTasksV1(@Nonnull TaskSearch taskSearch, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(searchTasksV1Async(taskSearch, requestOptions));
  }

  /**
   * Searches for tasks using the v1 endpoint, please use `searchTasks` instead.
   *
   * @param taskSearch (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public List<TaskV1> searchTasksV1(@Nonnull TaskSearch taskSearch) throws AlgoliaRuntimeException {
    return this.searchTasksV1(taskSearch, null);
  }

  /**
   * (asynchronously) Searches for tasks using the v1 endpoint, please use `searchTasks` instead.
   *
   * @param taskSearch (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<List<TaskV1>> searchTasksV1Async(@Nonnull TaskSearch taskSearch, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskSearch, "Parameter `taskSearch` is required when calling `searchTasksV1`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/tasks/search").setMethod("POST").setBody(taskSearch).build();
    return executeAsync(request, requestOptions, new TypeReference<List<TaskV1>>() {});
  }

  /**
   * (asynchronously) Searches for tasks using the v1 endpoint, please use `searchTasks` instead.
   *
   * @param taskSearch (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<List<TaskV1>> searchTasksV1Async(@Nonnull TaskSearch taskSearch) throws AlgoliaRuntimeException {
    return this.searchTasksV1Async(taskSearch, null);
  }

  /**
   * Searches for transformations.
   *
   * @param transformationSearch (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public List<Transformation> searchTransformations(
    @Nonnull TransformationSearch transformationSearch,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(searchTransformationsAsync(transformationSearch, requestOptions));
  }

  /**
   * Searches for transformations.
   *
   * @param transformationSearch (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public List<Transformation> searchTransformations(@Nonnull TransformationSearch transformationSearch) throws AlgoliaRuntimeException {
    return this.searchTransformations(transformationSearch, null);
  }

  /**
   * (asynchronously) Searches for transformations.
   *
   * @param transformationSearch (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<List<Transformation>> searchTransformationsAsync(
    @Nonnull TransformationSearch transformationSearch,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(transformationSearch, "Parameter `transformationSearch` is required when calling `searchTransformations`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/transformations/search")
      .setMethod("POST")
      .setBody(transformationSearch)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<List<Transformation>>() {});
  }

  /**
   * (asynchronously) Searches for transformations.
   *
   * @param transformationSearch (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<List<Transformation>> searchTransformationsAsync(@Nonnull TransformationSearch transformationSearch)
    throws AlgoliaRuntimeException {
    return this.searchTransformationsAsync(transformationSearch, null);
  }

  /**
   * Triggers a stream-listing request for a source. Triggering stream-listing requests only works
   * with sources with `type: docker` and `imageType: airbyte`.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse triggerDockerSourceDiscover(@Nonnull String sourceID, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(triggerDockerSourceDiscoverAsync(sourceID, requestOptions));
  }

  /**
   * Triggers a stream-listing request for a source. Triggering stream-listing requests only works
   * with sources with `type: docker` and `imageType: airbyte`.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse triggerDockerSourceDiscover(@Nonnull String sourceID) throws AlgoliaRuntimeException {
    return this.triggerDockerSourceDiscover(sourceID, null);
  }

  /**
   * (asynchronously) Triggers a stream-listing request for a source. Triggering stream-listing
   * requests only works with sources with `type: docker` and `imageType: airbyte`.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> triggerDockerSourceDiscoverAsync(
    @Nonnull String sourceID,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(sourceID, "Parameter `sourceID` is required when calling `triggerDockerSourceDiscover`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/sources/{sourceID}/discover", sourceID).setMethod("POST").build();
    return executeAsync(
      request,
      new RequestOptions()
        .setReadTimeout(Duration.ofMillis(180000L))
        .setWriteTimeout(Duration.ofMillis(180000L))
        .setConnectTimeout(Duration.ofMillis(180000L))
        .mergeRight(requestOptions),
      new TypeReference<WatchResponse>() {}
    );
  }

  /**
   * (asynchronously) Triggers a stream-listing request for a source. Triggering stream-listing
   * requests only works with sources with `type: docker` and `imageType: airbyte`.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> triggerDockerSourceDiscoverAsync(@Nonnull String sourceID) throws AlgoliaRuntimeException {
    return this.triggerDockerSourceDiscoverAsync(sourceID, null);
  }

  /**
   * Try a transformation before creating it.
   *
   * @param transformationTry (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TransformationTryResponse tryTransformation(@Nonnull TransformationTry transformationTry, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(tryTransformationAsync(transformationTry, requestOptions));
  }

  /**
   * Try a transformation before creating it.
   *
   * @param transformationTry (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TransformationTryResponse tryTransformation(@Nonnull TransformationTry transformationTry) throws AlgoliaRuntimeException {
    return this.tryTransformation(transformationTry, null);
  }

  /**
   * (asynchronously) Try a transformation before creating it.
   *
   * @param transformationTry (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TransformationTryResponse> tryTransformationAsync(
    @Nonnull TransformationTry transformationTry,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(transformationTry, "Parameter `transformationTry` is required when calling `tryTransformation`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/transformations/try").setMethod("POST").setBody(transformationTry).build();
    return executeAsync(request, requestOptions, new TypeReference<TransformationTryResponse>() {});
  }

  /**
   * (asynchronously) Try a transformation before creating it.
   *
   * @param transformationTry (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TransformationTryResponse> tryTransformationAsync(@Nonnull TransformationTry transformationTry)
    throws AlgoliaRuntimeException {
    return this.tryTransformationAsync(transformationTry, null);
  }

  /**
   * Try a transformation before updating it.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @param transformationTry (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TransformationTryResponse tryTransformationBeforeUpdate(
    @Nonnull String transformationID,
    @Nonnull TransformationTry transformationTry,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(tryTransformationBeforeUpdateAsync(transformationID, transformationTry, requestOptions));
  }

  /**
   * Try a transformation before updating it.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @param transformationTry (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TransformationTryResponse tryTransformationBeforeUpdate(
    @Nonnull String transformationID,
    @Nonnull TransformationTry transformationTry
  ) throws AlgoliaRuntimeException {
    return this.tryTransformationBeforeUpdate(transformationID, transformationTry, null);
  }

  /**
   * (asynchronously) Try a transformation before updating it.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @param transformationTry (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TransformationTryResponse> tryTransformationBeforeUpdateAsync(
    @Nonnull String transformationID,
    @Nonnull TransformationTry transformationTry,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(transformationID, "Parameter `transformationID` is required when calling `tryTransformationBeforeUpdate`.");

    Parameters.requireNonNull(transformationTry, "Parameter `transformationTry` is required when calling `tryTransformationBeforeUpdate`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/transformations/{transformationID}/try", transformationID)
      .setMethod("POST")
      .setBody(transformationTry)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<TransformationTryResponse>() {});
  }

  /**
   * (asynchronously) Try a transformation before updating it.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @param transformationTry (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TransformationTryResponse> tryTransformationBeforeUpdateAsync(
    @Nonnull String transformationID,
    @Nonnull TransformationTry transformationTry
  ) throws AlgoliaRuntimeException {
    return this.tryTransformationBeforeUpdateAsync(transformationID, transformationTry, null);
  }

  /**
   * Updates an authentication resource.
   *
   * @param authenticationID Unique identifier of an authentication resource. (required)
   * @param authenticationUpdate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public AuthenticationUpdateResponse updateAuthentication(
    @Nonnull String authenticationID,
    @Nonnull AuthenticationUpdate authenticationUpdate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(updateAuthenticationAsync(authenticationID, authenticationUpdate, requestOptions));
  }

  /**
   * Updates an authentication resource.
   *
   * @param authenticationID Unique identifier of an authentication resource. (required)
   * @param authenticationUpdate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public AuthenticationUpdateResponse updateAuthentication(
    @Nonnull String authenticationID,
    @Nonnull AuthenticationUpdate authenticationUpdate
  ) throws AlgoliaRuntimeException {
    return this.updateAuthentication(authenticationID, authenticationUpdate, null);
  }

  /**
   * (asynchronously) Updates an authentication resource.
   *
   * @param authenticationID Unique identifier of an authentication resource. (required)
   * @param authenticationUpdate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<AuthenticationUpdateResponse> updateAuthenticationAsync(
    @Nonnull String authenticationID,
    @Nonnull AuthenticationUpdate authenticationUpdate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(authenticationID, "Parameter `authenticationID` is required when calling `updateAuthentication`.");

    Parameters.requireNonNull(authenticationUpdate, "Parameter `authenticationUpdate` is required when calling `updateAuthentication`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/authentications/{authenticationID}", authenticationID)
      .setMethod("PATCH")
      .setBody(authenticationUpdate)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<AuthenticationUpdateResponse>() {});
  }

  /**
   * (asynchronously) Updates an authentication resource.
   *
   * @param authenticationID Unique identifier of an authentication resource. (required)
   * @param authenticationUpdate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<AuthenticationUpdateResponse> updateAuthenticationAsync(
    @Nonnull String authenticationID,
    @Nonnull AuthenticationUpdate authenticationUpdate
  ) throws AlgoliaRuntimeException {
    return this.updateAuthenticationAsync(authenticationID, authenticationUpdate, null);
  }

  /**
   * Updates the destination by its ID.
   *
   * @param destinationID Unique identifier of a destination. (required)
   * @param destinationUpdate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DestinationUpdateResponse updateDestination(
    @Nonnull String destinationID,
    @Nonnull DestinationUpdate destinationUpdate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(updateDestinationAsync(destinationID, destinationUpdate, requestOptions));
  }

  /**
   * Updates the destination by its ID.
   *
   * @param destinationID Unique identifier of a destination. (required)
   * @param destinationUpdate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public DestinationUpdateResponse updateDestination(@Nonnull String destinationID, @Nonnull DestinationUpdate destinationUpdate)
    throws AlgoliaRuntimeException {
    return this.updateDestination(destinationID, destinationUpdate, null);
  }

  /**
   * (asynchronously) Updates the destination by its ID.
   *
   * @param destinationID Unique identifier of a destination. (required)
   * @param destinationUpdate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DestinationUpdateResponse> updateDestinationAsync(
    @Nonnull String destinationID,
    @Nonnull DestinationUpdate destinationUpdate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(destinationID, "Parameter `destinationID` is required when calling `updateDestination`.");

    Parameters.requireNonNull(destinationUpdate, "Parameter `destinationUpdate` is required when calling `updateDestination`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/destinations/{destinationID}", destinationID)
      .setMethod("PATCH")
      .setBody(destinationUpdate)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<DestinationUpdateResponse>() {});
  }

  /**
   * (asynchronously) Updates the destination by its ID.
   *
   * @param destinationID Unique identifier of a destination. (required)
   * @param destinationUpdate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<DestinationUpdateResponse> updateDestinationAsync(
    @Nonnull String destinationID,
    @Nonnull DestinationUpdate destinationUpdate
  ) throws AlgoliaRuntimeException {
    return this.updateDestinationAsync(destinationID, destinationUpdate, null);
  }

  /**
   * Updates a source by its ID.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param sourceUpdate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public SourceUpdateResponse updateSource(
    @Nonnull String sourceID,
    @Nonnull SourceUpdate sourceUpdate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(updateSourceAsync(sourceID, sourceUpdate, requestOptions));
  }

  /**
   * Updates a source by its ID.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param sourceUpdate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public SourceUpdateResponse updateSource(@Nonnull String sourceID, @Nonnull SourceUpdate sourceUpdate) throws AlgoliaRuntimeException {
    return this.updateSource(sourceID, sourceUpdate, null);
  }

  /**
   * (asynchronously) Updates a source by its ID.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param sourceUpdate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<SourceUpdateResponse> updateSourceAsync(
    @Nonnull String sourceID,
    @Nonnull SourceUpdate sourceUpdate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(sourceID, "Parameter `sourceID` is required when calling `updateSource`.");

    Parameters.requireNonNull(sourceUpdate, "Parameter `sourceUpdate` is required when calling `updateSource`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/sources/{sourceID}", sourceID).setMethod("PATCH").setBody(sourceUpdate).build();
    return executeAsync(request, requestOptions, new TypeReference<SourceUpdateResponse>() {});
  }

  /**
   * (asynchronously) Updates a source by its ID.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param sourceUpdate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<SourceUpdateResponse> updateSourceAsync(@Nonnull String sourceID, @Nonnull SourceUpdate sourceUpdate)
    throws AlgoliaRuntimeException {
    return this.updateSourceAsync(sourceID, sourceUpdate, null);
  }

  /**
   * Updates a task by its ID.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param taskUpdate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TaskUpdateResponse updateTask(@Nonnull String taskID, @Nonnull TaskUpdate taskUpdate, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(updateTaskAsync(taskID, taskUpdate, requestOptions));
  }

  /**
   * Updates a task by its ID.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param taskUpdate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TaskUpdateResponse updateTask(@Nonnull String taskID, @Nonnull TaskUpdate taskUpdate) throws AlgoliaRuntimeException {
    return this.updateTask(taskID, taskUpdate, null);
  }

  /**
   * (asynchronously) Updates a task by its ID.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param taskUpdate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TaskUpdateResponse> updateTaskAsync(
    @Nonnull String taskID,
    @Nonnull TaskUpdate taskUpdate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `updateTask`.");

    Parameters.requireNonNull(taskUpdate, "Parameter `taskUpdate` is required when calling `updateTask`.");

    HttpRequest request = HttpRequest.builder().setPath("/2/tasks/{taskID}", taskID).setMethod("PATCH").setBody(taskUpdate).build();
    return executeAsync(request, requestOptions, new TypeReference<TaskUpdateResponse>() {});
  }

  /**
   * (asynchronously) Updates a task by its ID.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param taskUpdate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TaskUpdateResponse> updateTaskAsync(@Nonnull String taskID, @Nonnull TaskUpdate taskUpdate)
    throws AlgoliaRuntimeException {
    return this.updateTaskAsync(taskID, taskUpdate, null);
  }

  /**
   * Updates a task by its ID using the v1 endpoint, please use `updateTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param taskUpdate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public TaskUpdateResponse updateTaskV1(@Nonnull String taskID, @Nonnull TaskUpdateV1 taskUpdate, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    return LaunderThrowable.await(updateTaskV1Async(taskID, taskUpdate, requestOptions));
  }

  /**
   * Updates a task by its ID using the v1 endpoint, please use `updateTask` instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param taskUpdate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public TaskUpdateResponse updateTaskV1(@Nonnull String taskID, @Nonnull TaskUpdateV1 taskUpdate) throws AlgoliaRuntimeException {
    return this.updateTaskV1(taskID, taskUpdate, null);
  }

  /**
   * (asynchronously) Updates a task by its ID using the v1 endpoint, please use `updateTask`
   * instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param taskUpdate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<TaskUpdateResponse> updateTaskV1Async(
    @Nonnull String taskID,
    @Nonnull TaskUpdateV1 taskUpdate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(taskID, "Parameter `taskID` is required when calling `updateTaskV1`.");

    Parameters.requireNonNull(taskUpdate, "Parameter `taskUpdate` is required when calling `updateTaskV1`.");

    HttpRequest request = HttpRequest.builder().setPath("/1/tasks/{taskID}", taskID).setMethod("PATCH").setBody(taskUpdate).build();
    return executeAsync(request, requestOptions, new TypeReference<TaskUpdateResponse>() {});
  }

  /**
   * (asynchronously) Updates a task by its ID using the v1 endpoint, please use `updateTask`
   * instead.
   *
   * @param taskID Unique identifier of a task. (required)
   * @param taskUpdate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   * @deprecated
   */
  @Deprecated
  public CompletableFuture<TaskUpdateResponse> updateTaskV1Async(@Nonnull String taskID, @Nonnull TaskUpdateV1 taskUpdate)
    throws AlgoliaRuntimeException {
    return this.updateTaskV1Async(taskID, taskUpdate, null);
  }

  /**
   * Updates a transformation by its ID.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @param transformationCreate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TransformationUpdateResponse updateTransformation(
    @Nonnull String transformationID,
    @Nonnull TransformationCreate transformationCreate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(updateTransformationAsync(transformationID, transformationCreate, requestOptions));
  }

  /**
   * Updates a transformation by its ID.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @param transformationCreate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public TransformationUpdateResponse updateTransformation(
    @Nonnull String transformationID,
    @Nonnull TransformationCreate transformationCreate
  ) throws AlgoliaRuntimeException {
    return this.updateTransformation(transformationID, transformationCreate, null);
  }

  /**
   * (asynchronously) Updates a transformation by its ID.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @param transformationCreate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TransformationUpdateResponse> updateTransformationAsync(
    @Nonnull String transformationID,
    @Nonnull TransformationCreate transformationCreate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(transformationID, "Parameter `transformationID` is required when calling `updateTransformation`.");

    Parameters.requireNonNull(transformationCreate, "Parameter `transformationCreate` is required when calling `updateTransformation`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/transformations/{transformationID}", transformationID)
      .setMethod("PUT")
      .setBody(transformationCreate)
      .build();
    return executeAsync(request, requestOptions, new TypeReference<TransformationUpdateResponse>() {});
  }

  /**
   * (asynchronously) Updates a transformation by its ID.
   *
   * @param transformationID Unique identifier of a transformation. (required)
   * @param transformationCreate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<TransformationUpdateResponse> updateTransformationAsync(
    @Nonnull String transformationID,
    @Nonnull TransformationCreate transformationCreate
  ) throws AlgoliaRuntimeException {
    return this.updateTransformationAsync(transformationID, transformationCreate, null);
  }

  /**
   * Validates a source payload to ensure it can be created and that the data source can be reached
   * by Algolia.
   *
   * @param sourceCreate (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse validateSource(SourceCreate sourceCreate, @Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(validateSourceAsync(sourceCreate, requestOptions));
  }

  /**
   * Validates a source payload to ensure it can be created and that the data source can be reached
   * by Algolia.
   *
   * @param sourceCreate (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse validateSource(SourceCreate sourceCreate) throws AlgoliaRuntimeException {
    return this.validateSource(sourceCreate, null);
  }

  /**
   * Validates a source payload to ensure it can be created and that the data source can be reached
   * by Algolia.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse validateSource(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.validateSource(null, requestOptions);
  }

  /**
   * Validates a source payload to ensure it can be created and that the data source can be reached
   * by Algolia.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse validateSource() throws AlgoliaRuntimeException {
    return this.validateSource(null, null);
  }

  /**
   * (asynchronously) Validates a source payload to ensure it can be created and that the data
   * source can be reached by Algolia.
   *
   * @param sourceCreate (optional)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> validateSourceAsync(SourceCreate sourceCreate, @Nullable RequestOptions requestOptions)
    throws AlgoliaRuntimeException {
    HttpRequest request = HttpRequest.builder().setPath("/1/sources/validate").setMethod("POST").setBody(sourceCreate).build();
    return executeAsync(
      request,
      new RequestOptions()
        .setReadTimeout(Duration.ofMillis(180000L))
        .setWriteTimeout(Duration.ofMillis(180000L))
        .setConnectTimeout(Duration.ofMillis(180000L))
        .mergeRight(requestOptions),
      new TypeReference<WatchResponse>() {}
    );
  }

  /**
   * (asynchronously) Validates a source payload to ensure it can be created and that the data
   * source can be reached by Algolia.
   *
   * @param sourceCreate (optional)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> validateSourceAsync(SourceCreate sourceCreate) throws AlgoliaRuntimeException {
    return this.validateSourceAsync(sourceCreate, null);
  }

  /**
   * (asynchronously) Validates a source payload to ensure it can be created and that the data
   * source can be reached by Algolia.
   *
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> validateSourceAsync(@Nullable RequestOptions requestOptions) throws AlgoliaRuntimeException {
    return this.validateSourceAsync(null, requestOptions);
  }

  /**
   * (asynchronously) Validates a source payload to ensure it can be created and that the data
   * source can be reached by Algolia.
   *
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> validateSourceAsync() throws AlgoliaRuntimeException {
    return this.validateSourceAsync(null, null);
  }

  /**
   * Validates an update of a source payload to ensure it can be created and that the data source
   * can be reached by Algolia.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param sourceUpdate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse validateSourceBeforeUpdate(
    @Nonnull String sourceID,
    @Nonnull SourceUpdate sourceUpdate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    return LaunderThrowable.await(validateSourceBeforeUpdateAsync(sourceID, sourceUpdate, requestOptions));
  }

  /**
   * Validates an update of a source payload to ensure it can be created and that the data source
   * can be reached by Algolia.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param sourceUpdate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public WatchResponse validateSourceBeforeUpdate(@Nonnull String sourceID, @Nonnull SourceUpdate sourceUpdate)
    throws AlgoliaRuntimeException {
    return this.validateSourceBeforeUpdate(sourceID, sourceUpdate, null);
  }

  /**
   * (asynchronously) Validates an update of a source payload to ensure it can be created and that
   * the data source can be reached by Algolia.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param sourceUpdate (required)
   * @param requestOptions The requestOptions to send along with the query, they will be merged with
   *     the transporter requestOptions.
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> validateSourceBeforeUpdateAsync(
    @Nonnull String sourceID,
    @Nonnull SourceUpdate sourceUpdate,
    @Nullable RequestOptions requestOptions
  ) throws AlgoliaRuntimeException {
    Parameters.requireNonNull(sourceID, "Parameter `sourceID` is required when calling `validateSourceBeforeUpdate`.");

    Parameters.requireNonNull(sourceUpdate, "Parameter `sourceUpdate` is required when calling `validateSourceBeforeUpdate`.");

    HttpRequest request = HttpRequest.builder()
      .setPath("/1/sources/{sourceID}/validate", sourceID)
      .setMethod("POST")
      .setBody(sourceUpdate)
      .build();
    return executeAsync(
      request,
      new RequestOptions()
        .setReadTimeout(Duration.ofMillis(180000L))
        .setWriteTimeout(Duration.ofMillis(180000L))
        .setConnectTimeout(Duration.ofMillis(180000L))
        .mergeRight(requestOptions),
      new TypeReference<WatchResponse>() {}
    );
  }

  /**
   * (asynchronously) Validates an update of a source payload to ensure it can be created and that
   * the data source can be reached by Algolia.
   *
   * @param sourceID Unique identifier of a source. (required)
   * @param sourceUpdate (required)
   * @throws AlgoliaRuntimeException If it fails to process the API call
   */
  public CompletableFuture<WatchResponse> validateSourceBeforeUpdateAsync(@Nonnull String sourceID, @Nonnull SourceUpdate sourceUpdate)
    throws AlgoliaRuntimeException {
    return this.validateSourceBeforeUpdateAsync(sourceID, sourceUpdate, null);
  }

  private <T> List<PushTaskRecords> objectsToPushTaskRecords(Iterable<T> objects) {
    try {
      ObjectMapper mapper = new ObjectMapper();
      String json = mapper.writeValueAsString(objects);

      return mapper.readValue(json, new TypeReference<List<PushTaskRecords>>() {});
    } catch (Exception e) {
      throw new AlgoliaRuntimeException("each object must have an `objectID` key in order to be indexed");
    }
  }

  /**
   * Helper: Chunks the given `objects` list in subset of 1000 elements max in order to make it fit
   * in `push` requests by leveraging the Transformation pipeline setup in the Push connector
   * (https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/connectors/push/).
   *
   * @summary Helper: Chunks the given `objects` list in subset of 1000 elements max in order to
   *     make it fit in `batch` requests.
   * @param indexName - The `indexName` to replace `objects` in.
   * @param objects - The array of `objects` to store in the given Algolia `indexName`.
   * @param action - The `batch` `action` to perform on the given array of `objects`.
   * @param waitForTasks - Whether or not we should wait until every `batch` tasks has been
   *     processed, this operation may slow the total execution time of this method but is more
   *     reliable.
   * @param batchSize - The size of the chunk of `objects`. The number of `batch` calls will be
   *     equal to `length(objects) / batchSize`. Defaults to 1000.
   * @param referenceIndexName - This is required when targeting an index that does not have a push
   *     connector setup (e.g. a tmp index), but you wish to attach another index's transformation
   *     to it (e.g. the source index name).
   * @param requestOptions - The requestOptions to send along with the query, they will be forwarded
   *     to the `getEvent` method and merged with the transporter requestOptions.
   */
  public <T> List<WatchResponse> chunkedPush(
    String indexName,
    Iterable<T> objects,
    Action action,
    boolean waitForTasks,
    int batchSize,
    String referenceIndexName,
    RequestOptions requestOptions
  ) {
    List<WatchResponse> responses = new ArrayList<>();
    List<T> records = new ArrayList<>();

    for (T item : objects) {
      if (records.size() == batchSize) {
        WatchResponse watch =
          this.push(
              indexName,
              new PushTaskPayload().setAction(action).setRecords(this.objectsToPushTaskRecords(records)),
              waitForTasks,
              referenceIndexName,
              requestOptions
            );
        responses.add(watch);
        records.clear();
      }

      records.add(item);
    }

    if (records.size() > 0) {
      WatchResponse watch =
        this.push(
            indexName,
            new PushTaskPayload().setAction(action).setRecords(this.objectsToPushTaskRecords(records)),
            waitForTasks,
            referenceIndexName,
            requestOptions
          );
      responses.add(watch);
    }

    if (waitForTasks) {
      responses.forEach(response -> {
        TaskUtils.retryUntil(
          () -> {
            try {
              return this.getEvent(response.getRunID(), response.getEventID());
            } catch (AlgoliaApiException e) {
              if (e.getStatusCode() == 404) {
                return null;
              }

              throw e;
            }
          },
          (Event resp) -> {
            return resp != null;
          },
          50,
          null
        );
      });
    }

    return responses;
  }
}
