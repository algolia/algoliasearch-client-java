import { shuffle } from '../utils/helpers';
import { Transporter } from '../utils/Transporter'; 
import { Headers, Host, Request, RequestOptions } from '../utils/types';
import { Requester } from '../utils/requester/Requester';

{{#imports}}
import { {{classname}} } from '{{filename}}';
{{/imports}}
{{#hasAuthMethods}}
import { ApiKeyAuth } from '../model/models';
{{/hasAuthMethods}}

{{#operations}}
{{#description}}
/**
* {{&description}}
*/
{{/description}}

export enum {{classname}}Keys {
  {{#authMethods}}
  {{#isApiKey}}
  {{name}},
  {{/isApiKey}}
  {{/authMethods}}
}

export class {{classname}} {
  protected authentications = {
    {{#hasAuthMethods}}
    {{#authMethods}}
    {{#isApiKey}}
    '{{name}}': new ApiKeyAuth({{#isKeyInHeader}}'header'{{/isKeyInHeader}}{{#isKeyInQuery}}'query'{{/isKeyInQuery}}{{#isKeyInCookie}}'cookie'{{/isKeyInCookie}}, '{{keyParamName}}'),
    {{/isApiKey}}
    {{/authMethods}}
    {{/hasAuthMethods}}
  }

  private transporter: Transporter;
  
  private sendRequest<TResponse>(request: Request, requestOptions: RequestOptions): Promise<TResponse> {
    {{#authMethods}}
    {{#isApiKey}}
    if (this.authentications.{{name}}.apiKey) {
    this.authentications.{{name}}.applyToRequest(requestOptions);
    }
    
    {{/isApiKey}}
    {{/authMethods}}
    return this.transporter.request(request, requestOptions);
  }

  constructor(
      appId: string,
      apiKey: string,
      {{#hasRegionalHost}}
        {{#isPersonalizationHost}}
            region?: string,
        {{/isPersonalizationHost}}
        {{#isAnalyticsHost}}
            region: 'de' | 'us',
        {{/isAnalyticsHost}}
      {{/hasRegionalHost}}
      options?: {requester?: Requester, hosts?: Host[]}
    ) {
    this.setApiKey({{classname}}Keys.appId, appId);
    this.setApiKey({{classname}}Keys.apiKey, apiKey);

    this.transporter = new Transporter({
      hosts: options?.hosts ?? this.getDefaultHosts(
        {{#isSearchHost}}appId{{/isSearchHost}}
        {{#hasRegionalHost}}region{{/hasRegionalHost}}
    ),
      baseHeaders: {
        'content-type': 'application/x-www-form-urlencoded'
      },
      userAgent: 'Algolia for Javascript',
      timeouts: {
        connect: 2,
        read: 5,
        write: 30,
      },
      requester: options?.requester,
    });
  }

  {{#isSearchHost}}
  public getDefaultHosts(appId: string): Host[] {
    return (
        [
          { url: `${appId}-dsn.algolia.net`, accept: 'read', protocol: 'https' },
          { url: `${appId}.algolia.net`, accept: 'write', protocol: 'https' },
        ] as Host[]
      ).concat(
        shuffle([
          { url: `${appId}-1.algolianet.com`, accept: 'readWrite', protocol: 'https' },
          { url: `${appId}-2.algolianet.com`, accept: 'readWrite', protocol: 'https' },
          { url: `${appId}-3.algolianet.com`, accept: 'readWrite', protocol: 'https' },
        ])
      );
  }
  {{/isSearchHost}}

  {{#isPersonalizationHost}}
  public getDefaultHosts(region: string = 'us'): Host[] {
    return [{ url: `personalization.${region}.algolia.com`, accept: 'readWrite', protocol: 'https' }];
  }
  {{/isPersonalizationHost}}

  {{#isAnalyticsHost}}
  public getDefaultHosts(region: 'de' | 'us'): Host[] {
    return [{ url: `analytics.${region}.algolia.com`, accept: 'readWrite', protocol: 'https' }];
  }
  {{/isAnalyticsHost}}

  {{#isInsightsHost}}
  public getDefaultHosts(): Host[] {
    return [{ url: `insights.algolia.io`, accept: 'readWrite', protocol: 'https' }];
  }
  {{/isInsightsHost}}

  public setRequest(requester: Requester): void {
    this.transporter.setRequester(requester);
  }

  public setHosts(hosts: Host[]): void {
    this.transporter.setHosts(hosts);
  }

  public setApiKey(key: {{classname}}Keys, value: string): void {
    this.authentications[{{classname}}Keys[key]].apiKey = value;
  }

  {{#operation}}
  /**
  {{#notes}}
  * {{&notes}}
  {{/notes}}
  {{#summary}}
  * @summary {{&summary}}
  {{/summary}}
  * @param {{nickname}} - The {{nickname}} parameters.
  {{#allParams}}
  * @param {{nickname}}.{{paramName}} {{^description}}The {{paramName}}{{/description}}{{#description}}{{{description}}}{{/description}}
  {{/allParams}}
  */
  public {{nickname}} (
      {{#allParams.0}}
        {
          {{#allParams}}
            {{paramName}},
          {{/allParams}}
        }: {{#lambda.titlecase}}{{nickname}}{{/lambda.titlecase}}Props
      {{/allParams.0}}
      ) : Promise<{{{returnType}}}> {
    const path = '{{{path}}}'{{#pathParams}}.replace(
    {{=<% %>=}}
      '{<%baseName%>}',
    <%={{ }}=%>
      encodeURIComponent(String({{paramName}}))
    ){{/pathParams}};
    let headers: Headers = { Accept: 'application/json' };
    let queryParameters: Record<string, string> = {};

    {{#allParams}}
    {{#required}}
    if ({{paramName}} === null || {{paramName}} === undefined) {
      throw new Error('Required parameter {{paramName}} was null or undefined when calling {{nickname}}.');
    }

    {{#vars}}
    {{#required}}
    if ({{paramName}}.{{baseName}} === null || {{paramName}}.{{baseName}} === undefined) {
      throw new Error('Required parameter {{paramName}}.{{baseName}} was null or undefined when calling {{nickname}}.');
    }
    {{/required}}
    {{/vars}}

    {{/required}}
    {{/allParams}}
    {{#queryParams}}
    if ({{paramName}} !== undefined) {
      queryParameters['{{baseName}}'] = {{paramName}}.toString();
    }

    {{/queryParams}}
    {{#headerParams}}
    headers['{{baseName}}'] = {{paramName}};
    {{/headerParams}}

    const request: Request = {
      method: '{{httpMethod}}',
      path,
      {{#bodyParam}}
      data: {{paramName}},
      {{/bodyParam}}
    };

    const requestOptions: RequestOptions = {
      headers,
      queryParameters
    };

    return this.sendRequest(request, requestOptions);
  }
  {{/operation}}
}

{{#operation}}
{{#allParams.0}}
export type {{#lambda.titlecase}}{{nickname}}{{/lambda.titlecase}}Props = {
  {{#allParams}}
    {{paramName}}{{^required}}?{{/required}}: {{{dataType}}};
  {{/allParams}}
}
{{/allParams.0}}

{{/operation}}

{{/operations}}
